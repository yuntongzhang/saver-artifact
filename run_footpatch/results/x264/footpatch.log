rm -f  common/osdep.o common/base.o common/cpu.o common/tables.o encoder/api.o common/mc-8.o common/predict-8.o common/pixel-8.o common/macroblock-8.o common/frame-8.o common/dct-8.o common/cabac-8.o common/common-8.o common/rectangle-8.o common/set-8.o common/quant-8.o common/deblock-8.o common/vlc-8.o common/mvpred-8.o common/bitstream-8.o encoder/analyse-8.o encoder/me-8.o encoder/ratecontrol-8.o encoder/set-8.o encoder/macroblock-8.o encoder/cabac-8.o encoder/cavlc-8.o encoder/encoder-8.o encoder/lookahead-8.o common/threadpool-8.o common/x86/mc-c-8.o common/x86/predict-c-8.o common/opencl-8.o encoder/slicetype-cl-8.o common/mc-10.o common/predict-10.o common/pixel-10.o common/macroblock-10.o common/frame-10.o common/dct-10.o common/cabac-10.o common/common-10.o common/rectangle-10.o common/set-10.o common/quant-10.o common/deblock-10.o common/vlc-10.o common/mvpred-10.o common/bitstream-10.o encoder/analyse-10.o encoder/me-10.o encoder/ratecontrol-10.o encoder/set-10.o encoder/macroblock-10.o encoder/cabac-10.o encoder/cavlc-10.o encoder/encoder-10.o encoder/lookahead-10.o common/threadpool-10.o common/x86/mc-c-10.o common/x86/predict-c-10.o  common/x86/cpu-a.o common/x86/dct-64-8.o common/x86/trellis-64-8.o common/x86/bitstream-a-8.o common/x86/const-a-8.o common/x86/cabac-a-8.o common/x86/dct-a-8.o common/x86/deblock-a-8.o common/x86/mc-a-8.o common/x86/mc-a2-8.o common/x86/pixel-a-8.o common/x86/predict-a-8.o common/x86/quant-a-8.o common/x86/sad-a-8.o common/x86/dct-64-10.o common/x86/trellis-64-10.o common/x86/bitstream-a-10.o common/x86/const-a-10.o common/x86/cabac-a-10.o common/x86/dct-a-10.o common/x86/deblock-a-10.o common/x86/mc-a-10.o common/x86/mc-a2-10.o common/x86/pixel-a-10.o common/x86/predict-a-10.o common/x86/quant-a-10.o common/x86/sad16-a-10.o  x264.o autocomplete.o input/input.o input/timecode.o input/raw.o input/y4m.o output/raw.o output/matroska.o output/matroska_ebml.o output/flv.o output/flv_bytestream.o filters/filters.o filters/video/video.o filters/video/source.o filters/video/internal.o filters/video/resize.o filters/video/fix_vfr_pts.o filters/video/select_every.o filters/video/crop.o input/avs.o filters/video/cache-8.o filters/video/depth-8.o input/thread-8.o filters/video/cache-10.o filters/video/depth-10.o input/thread-10.o    common/oclobj.h .depend TAGS
rm -f  *.a *.lib *.exp *.pdb x264 x264_lookahead.clbin
rm -f checkasm8 checkasm10  tools/checkasm-a.o  tools/checkasm-8.o  tools/checkasm-10.o
rm -f example  example.o
rm -f common/osdep.gcda common/base.gcda common/cpu.gcda common/tables.gcda encoder/api.gcda common/mc-8.gcda common/predict-8.gcda common/pixel-8.gcda common/macroblock-8.gcda common/frame-8.gcda common/dct-8.gcda common/cabac-8.gcda common/common-8.gcda common/rectangle-8.gcda common/set-8.gcda common/quant-8.gcda common/deblock-8.gcda common/vlc-8.gcda common/mvpred-8.gcda common/bitstream-8.gcda encoder/analyse-8.gcda encoder/me-8.gcda encoder/ratecontrol-8.gcda encoder/set-8.gcda encoder/macroblock-8.gcda encoder/cabac-8.gcda encoder/cavlc-8.gcda encoder/encoder-8.gcda encoder/lookahead-8.gcda common/threadpool-8.gcda common/x86/mc-c-8.gcda common/x86/predict-c-8.gcda common/opencl-8.gcda encoder/slicetype-cl-8.gcda common/mc-10.gcda common/predict-10.gcda common/pixel-10.gcda common/macroblock-10.gcda common/frame-10.gcda common/dct-10.gcda common/cabac-10.gcda common/common-10.gcda common/rectangle-10.gcda common/set-10.gcda common/quant-10.gcda common/deblock-10.gcda common/vlc-10.gcda common/mvpred-10.gcda common/bitstream-10.gcda encoder/analyse-10.gcda encoder/me-10.gcda encoder/ratecontrol-10.gcda encoder/set-10.gcda encoder/macroblock-10.gcda encoder/cabac-10.gcda encoder/cavlc-10.gcda encoder/encoder-10.gcda encoder/lookahead-10.gcda common/threadpool-10.gcda common/x86/mc-c-10.gcda common/x86/predict-c-10.gcda x264.gcda autocomplete.gcda input/input.gcda input/timecode.gcda input/raw.gcda input/y4m.gcda output/raw.gcda output/matroska.gcda output/matroska_ebml.gcda output/flv.gcda output/flv_bytestream.gcda filters/filters.gcda filters/video/video.gcda filters/video/source.gcda filters/video/internal.gcda filters/video/resize.gcda filters/video/fix_vfr_pts.gcda filters/video/select_every.gcda filters/video/crop.gcda input/avs.gcda filters/video/cache-8.gcda filters/video/depth-8.gcda input/thread-8.gcda filters/video/cache-10.gcda filters/video/depth-10.gcda input/thread-10.gcda common/osdep.gcno common/base.gcno common/cpu.gcno common/tables.gcno encoder/api.gcno common/mc-8.gcno common/predict-8.gcno common/pixel-8.gcno common/macroblock-8.gcno common/frame-8.gcno common/dct-8.gcno common/cabac-8.gcno common/common-8.gcno common/rectangle-8.gcno common/set-8.gcno common/quant-8.gcno common/deblock-8.gcno common/vlc-8.gcno common/mvpred-8.gcno common/bitstream-8.gcno encoder/analyse-8.gcno encoder/me-8.gcno encoder/ratecontrol-8.gcno encoder/set-8.gcno encoder/macroblock-8.gcno encoder/cabac-8.gcno encoder/cavlc-8.gcno encoder/encoder-8.gcno encoder/lookahead-8.gcno common/threadpool-8.gcno common/x86/mc-c-8.gcno common/x86/predict-c-8.gcno common/opencl-8.gcno encoder/slicetype-cl-8.gcno common/mc-10.gcno common/predict-10.gcno common/pixel-10.gcno common/macroblock-10.gcno common/frame-10.gcno common/dct-10.gcno common/cabac-10.gcno common/common-10.gcno common/rectangle-10.gcno common/set-10.gcno common/quant-10.gcno common/deblock-10.gcno common/vlc-10.gcno common/mvpred-10.gcno common/bitstream-10.gcno encoder/analyse-10.gcno encoder/me-10.gcno encoder/ratecontrol-10.gcno encoder/set-10.gcno encoder/macroblock-10.gcno encoder/cabac-10.gcno encoder/cavlc-10.gcno encoder/encoder-10.gcno encoder/lookahead-10.gcno common/threadpool-10.gcno common/x86/mc-c-10.gcno common/x86/predict-c-10.gcno x264.gcno autocomplete.gcno input/input.gcno input/timecode.gcno input/raw.gcno input/y4m.gcno output/raw.gcno output/matroska.gcno output/matroska_ebml.gcno output/flv.gcno output/flv_bytestream.gcno filters/filters.gcno filters/video/video.gcno filters/video/source.gcno filters/video/internal.gcno filters/video/resize.gcno filters/video/fix_vfr_pts.gcno filters/video/select_every.gcno filters/video/crop.gcno input/avs.gcno filters/video/cache-8.gcno filters/video/depth-8.gcno input/thread-8.gcno filters/video/cache-10.gcno filters/video/depth-10.gcno input/thread-10.gcno *.dyn pgopti.dpi pgopti.dpi.lock *.pgd *.pgc
cat common/opencl/x264-cl.h common/opencl/motionsearch.cl common/opencl/subpel.cl common/opencl/intra.cl common/opencl/weightp.cl common/opencl/bidir.cl common/opencl/downscale.cl | ./tools/cltostr.sh common/oclobj.h
dependency file generation...
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c x264.c -o x264.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c autocomplete.c -o autocomplete.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/input.c -o input/input.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/timecode.c -o input/timecode.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/raw.c -o input/raw.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/y4m.c -o input/y4m.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/raw.c -o output/raw.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/matroska.c -o output/matroska.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/matroska_ebml.c -o output/matroska_ebml.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/flv.c -o output/flv.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/flv_bytestream.c -o output/flv_bytestream.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/filters.c -o filters/filters.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/video.c -o filters/video/video.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/source.c -o filters/video/source.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/internal.c -o filters/video/internal.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/resize.c -o filters/video/resize.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/fix_vfr_pts.c -o filters/video/fix_vfr_pts.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/select_every.c -o filters/video/select_every.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/crop.c -o filters/video/crop.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/avs.c -o input/avs.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/cache.c -o filters/video/cache-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/depth.c -o filters/video/depth-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/thread.c -o input/thread-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/cache.c -o filters/video/cache-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/depth.c -o filters/video/depth-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/thread.c -o input/thread-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/osdep.c -o common/osdep.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/base.c -o common/base.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/cpu.c -o common/cpu.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/tables.c -o common/tables.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/api.c -o encoder/api.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mc.c -o common/mc-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/predict.c -o common/predict-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/pixel.c -o common/pixel-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/macroblock.c -o common/macroblock-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/frame.c -o common/frame-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/dct.c -o common/dct-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/cabac.c -o common/cabac-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/common.c -o common/common-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/rectangle.c -o common/rectangle-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/set.c -o common/set-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/quant.c -o common/quant-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/deblock.c -o common/deblock-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/vlc.c -o common/vlc-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mvpred.c -o common/mvpred-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/bitstream.c -o common/bitstream-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/analyse.c -o encoder/analyse-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/me.c -o encoder/me-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/ratecontrol.c -o encoder/ratecontrol-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/set.c -o encoder/set-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/macroblock.c -o encoder/macroblock-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cabac.c -o encoder/cabac-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cavlc.c -o encoder/cavlc-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/encoder.c -o encoder/encoder-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/lookahead.c -o encoder/lookahead-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/threadpool.c -o common/threadpool-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/mc-c.c -o common/x86/mc-c-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/predict-c.c -o common/x86/predict-c-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/opencl.c -o common/opencl-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/slicetype-cl.c -o encoder/slicetype-cl-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mc.c -o common/mc-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/predict.c -o common/predict-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/pixel.c -o common/pixel-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/macroblock.c -o common/macroblock-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/frame.c -o common/frame-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/dct.c -o common/dct-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/cabac.c -o common/cabac-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/common.c -o common/common-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/rectangle.c -o common/rectangle-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/set.c -o common/set-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/quant.c -o common/quant-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/deblock.c -o common/deblock-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/vlc.c -o common/vlc-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mvpred.c -o common/mvpred-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/bitstream.c -o common/bitstream-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/analyse.c -o encoder/analyse-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/me.c -o encoder/me-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/ratecontrol.c -o encoder/ratecontrol-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/set.c -o encoder/set-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/macroblock.c -o encoder/macroblock-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cabac.c -o encoder/cabac-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cavlc.c -o encoder/cavlc-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/encoder.c -o encoder/encoder-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/lookahead.c -o encoder/lookahead-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/threadpool.c -o common/threadpool-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/mc-c.c -o common/x86/mc-c-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/predict-c.c -o common/x86/predict-c-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/cpu-a.o common/x86/cpu-a.asm
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-64-8.o common/x86/dct-64.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/trellis-64-8.o common/x86/trellis-64.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/bitstream-a-8.o common/x86/bitstream-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/const-a-8.o common/x86/const-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/cabac-a-8.o common/x86/cabac-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-a-8.o common/x86/dct-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/deblock-a-8.o common/x86/deblock-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a-8.o common/x86/mc-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a2-8.o common/x86/mc-a2.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/pixel-a-8.o common/x86/pixel-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/predict-a-8.o common/x86/predict-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/quant-a-8.o common/x86/quant-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/sad-a-8.o common/x86/sad-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-64-10.o common/x86/dct-64.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/trellis-64-10.o common/x86/trellis-64.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/bitstream-a-10.o common/x86/bitstream-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/const-a-10.o common/x86/const-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/cabac-a-10.o common/x86/cabac-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-a-10.o common/x86/dct-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/deblock-a-10.o common/x86/deblock-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a-10.o common/x86/mc-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a2-10.o common/x86/mc-a2.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/pixel-a-10.o common/x86/pixel-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/predict-a-10.o common/x86/predict-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/quant-a-10.o common/x86/quant-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/sad16-a-10.o common/x86/sad16-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
rm -f libx264.a
gcc-ar rc libx264.a  common/osdep.o common/base.o common/cpu.o common/tables.o encoder/api.o common/mc-8.o common/predict-8.o common/pixel-8.o common/macroblock-8.o common/frame-8.o common/dct-8.o common/cabac-8.o common/common-8.o common/rectangle-8.o common/set-8.o common/quant-8.o common/deblock-8.o common/vlc-8.o common/mvpred-8.o common/bitstream-8.o encoder/analyse-8.o encoder/me-8.o encoder/ratecontrol-8.o encoder/set-8.o encoder/macroblock-8.o encoder/cabac-8.o encoder/cavlc-8.o encoder/encoder-8.o encoder/lookahead-8.o common/threadpool-8.o common/x86/mc-c-8.o common/x86/predict-c-8.o common/opencl-8.o encoder/slicetype-cl-8.o common/mc-10.o common/predict-10.o common/pixel-10.o common/macroblock-10.o common/frame-10.o common/dct-10.o common/cabac-10.o common/common-10.o common/rectangle-10.o common/set-10.o common/quant-10.o common/deblock-10.o common/vlc-10.o common/mvpred-10.o common/bitstream-10.o encoder/analyse-10.o encoder/me-10.o encoder/ratecontrol-10.o encoder/set-10.o encoder/macroblock-10.o encoder/cabac-10.o encoder/cavlc-10.o encoder/encoder-10.o encoder/lookahead-10.o common/threadpool-10.o common/x86/mc-c-10.o common/x86/predict-c-10.o  common/x86/cpu-a.o common/x86/dct-64-8.o common/x86/trellis-64-8.o common/x86/bitstream-a-8.o common/x86/const-a-8.o common/x86/cabac-a-8.o common/x86/dct-a-8.o common/x86/deblock-a-8.o common/x86/mc-a-8.o common/x86/mc-a2-8.o common/x86/pixel-a-8.o common/x86/predict-a-8.o common/x86/quant-a-8.o common/x86/sad-a-8.o common/x86/dct-64-10.o common/x86/trellis-64-10.o common/x86/bitstream-a-10.o common/x86/const-a-10.o common/x86/cabac-a-10.o common/x86/dct-a-10.o common/x86/deblock-a-10.o common/x86/mc-a-10.o common/x86/mc-a2-10.o common/x86/pixel-a-10.o common/x86/predict-a-10.o common/x86/quant-a-10.o common/x86/sad16-a-10.o
gcc-ranlib libx264.a
gcc -o x264  x264.o autocomplete.o input/input.o input/timecode.o input/raw.o input/y4m.o output/raw.o output/matroska.o output/matroska_ebml.o output/flv.o output/flv_bytestream.o filters/filters.o filters/video/video.o filters/video/source.o filters/video/internal.o filters/video/resize.o filters/video/fix_vfr_pts.o filters/video/select_every.o filters/video/crop.o input/avs.o filters/video/cache-8.o filters/video/depth-8.o input/thread-8.o filters/video/cache-10.o filters/video/depth-10.o input/thread-10.o libx264.a -ldl  -m64  -lm -lpthread -ldl
Starting analysis (Infer version v0.9.3)

legend:
  "F" analyzing a file
  "." analyzing a procedure

Dumping ALL candidates to DB /tmp/td_candidates/td_candidates_6f833c.db
SEARCH STORE SIZE 0
SIZE OF ERRORS: 0

Analyzed 57 files

Found 298 issues

/usr/include/x86_64-linux-gnu/bits/string2.h:1215: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1215, column 14
  1213.       {
  1214.         char *__cp = __retval;
  1215. >       while (1)
  1216.   	{
  1217.   	  if (*__cp == '\0')
  1218.   

/usr/include/x86_64-linux-gnu/bits/string2.h:1243: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1243, column 14
  1241.       {
  1242.         char *__cp = __retval;
  1243. >       while (1)
  1244.   	{
  1245.   	  if (*__cp == '\0')
  1246.   

autocomplete.c:292: warning: PRECONDITION_NOT_MET
  in call to strlen() at line 292, column 19
  290.   int x264_cli_autocomplete( const char *prev, const char *cur )
  291.   {
  292. >     int cur_len = strlen( cur );
  293.       if( 0 );
  294.       OPT( "--alternative-transfer" )
  295.   

common/base.c:186: error: ARRAY_OUT_OF_BOUNDS_L1
  array buf last assigned on line 174 could be accessed with index -1 out of bounds at line 186, column 9
  184.       }
  185.   
  186. >     if( buf[i_size-1] != '\n' )
  187.           buf[i_size++] = '\n';
  188.       buf[i_size] = '\0';
  189.   

common/base.c:799: warning: UNINITIALIZED_VALUE
  value coef was not initialized after declaration and is used at line 799, column 44
  797.       do {
  798.           int coef;
  799. >         if( !sscanf( str, "%d", &coef ) || coef < 1 || coef > 255 )
  800.               return -1;
  801.           cqm[i++] = coef;
  802.   

common/base.c:802: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((44==0)!=0) is always false at line 802, column 35
  800.               return -1;
  801.           cqm[i++] = coef;
  802. >     } while( i < length && (str = strchr( str, ',' )) && str++ );
  803.       return (i == length) ? 0 : -1;
  804.   }
  805.   

common/bitstream.c:35: error: ARRAY_OUT_OF_BOUNDS_L1
  array dst last assigned on line 32 could be accessed with index -2 out of bounds at line 35, column 32
  33.       while( src < end )
  34.       {
  35. >         if( src[0] <= 0x03 && !dst[-2] && !dst[-1] )
  36.               *dst++ = 0x03;
  37.           *dst++ = *src++;
  38.   

common/cabac.c:89: error: ARRAY_OUT_OF_BOUNDS_L1
  array cb->p could be accessed with index -1 out of bounds at line 89, column 13
  87.               // this can't carry beyond the one byte, because any 0xff bytes
  88.               // are in bytes_outstanding and thus not written yet.
  89. >             cb->p[-1] += carry;
  90.               while( bytes_outstanding > 0 )
  91.               {
  92.   

common/cabac.c:176: warning: PRECONDITION_NOT_MET
  in call to cabac_putbyte() at line 176, column 5
  174.       cb->i_low |= (0x35a4e4f5 >> (h->i_frame & 31) & 1) << 10;
  175.       cb->i_queue = 0;
  176. >     cabac_putbyte( cb );
  177.   
  178.       while( cb->i_bytes_outstanding > 0 )
  179.   

common/frame.c:852: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 852, column 5
  850.       slist->i_max_size = max_size;
  851.       slist->i_size = 0;
  852. >     CHECKED_MALLOCZERO( slist->list, (max_size+1) * sizeof(x264_frame_t*) );
  853.       if( x264_pthread_mutex_init( &slist->mutex, NULL ) ||
  854.           x264_pthread_cond_init( &slist->cv_fill, NULL ) ||
  855.   

common/macroblock.c:44: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 44, column 5
  42.       int mvy   = x264_clip3( h->mb.cache.mv[0][i8][1], h->mb.mv_min[1], h->mb.mv_max[1] ) + 4*4*y;
  43.   
  44. >     MC_LUMA( 0, 0 );
  45.   
  46.       if( CHROMA444 )
  47.   

common/macroblock.c:83: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 83, column 5
  81.       int mvy   = x264_clip3( h->mb.cache.mv[1][i8][1], h->mb.mv_min[1], h->mb.mv_max[1] ) + 4*4*y;
  82.   
  83. >     MC_LUMA( 1, 0 );
  84.   
  85.       if( CHROMA444 )
  86.   

common/macroblock.c:260: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 260, column 5
  258.       PREALLOC_INIT
  259.   
  260. >     PREALLOC( h->mb.qp, i_mb_count * sizeof(int8_t) );
  261.       PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262.       PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263.   

common/macroblock.c:261: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 261, column 5
  259.   
  260.       PREALLOC( h->mb.qp, i_mb_count * sizeof(int8_t) );
  261. >     PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262.       PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263.       PREALLOC( h->mb.slice_table, i_mb_count * sizeof(uint32_t) );
  264.   

common/macroblock.c:262: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 262, column 5
  260.       PREALLOC( h->mb.qp, i_mb_count * sizeof(int8_t) );
  261.       PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262. >     PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263.       PREALLOC( h->mb.slice_table, i_mb_count * sizeof(uint32_t) );
  264.   
  265.   

common/macroblock.c:263: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 263, column 5
  261.       PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262.       PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263. >     PREALLOC( h->mb.slice_table, i_mb_count * sizeof(uint32_t) );
  264.   
  265.       /* 0 -> 3 top(4), 4 -> 6 : left(3) */
  266.   

common/macroblock.c:266: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 266, column 5
  264.   
  265.       /* 0 -> 3 top(4), 4 -> 6 : left(3) */
  266. >     PREALLOC( h->mb.intra4x4_pred_mode, i_mb_count * 8 * sizeof(int8_t) );
  267.   
  268.       /* all coeffs */
  269.   

common/macroblock.c:269: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 269, column 5
  267.   
  268.       /* all coeffs */
  269. >     PREALLOC( h->mb.non_zero_count, i_mb_count * 48 * sizeof(uint8_t) );
  270.   
  271.       if( h->param.b_cabac )
  272.   

common/macroblock.c:273: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 273, column 9
  271.       if( h->param.b_cabac )
  272.       {
  273. >         PREALLOC( h->mb.skipbp, i_mb_count * sizeof(int8_t) );
  274.           PREALLOC( h->mb.chroma_pred_mode, i_mb_count * sizeof(int8_t) );
  275.           PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.   

common/macroblock.c:274: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 274, column 9
  272.       {
  273.           PREALLOC( h->mb.skipbp, i_mb_count * sizeof(int8_t) );
  274. >         PREALLOC( h->mb.chroma_pred_mode, i_mb_count * sizeof(int8_t) );
  275.           PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.           if( h->param.i_bframe )
  277.   

common/macroblock.c:275: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 275, column 9
  273.           PREALLOC( h->mb.skipbp, i_mb_count * sizeof(int8_t) );
  274.           PREALLOC( h->mb.chroma_pred_mode, i_mb_count * sizeof(int8_t) );
  275. >         PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.           if( h->param.i_bframe )
  277.               PREALLOC( h->mb.mvd[1], i_mb_count * sizeof( **h->mb.mvd ) );
  278.   

common/macroblock.c:277: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 277, column 13
  275.           PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.           if( h->param.i_bframe )
  277. >             PREALLOC( h->mb.mvd[1], i_mb_count * sizeof( **h->mb.mvd ) );
  278.       }
  279.   
  280.   

common/macroblock.c:394: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 394, column 9
  392.       scratch_size = X264_MAX( scratch_size, buf_mbtree );
  393.       if( scratch_size )
  394. >         CHECKED_MALLOC( h->scratch_buffer, scratch_size );
  395.       else
  396.           h->scratch_buffer = NULL;
  397.   

common/macroblock.c:437: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fref[0] of size 2 could be accessed with an index out of bounds at line 437, column 34
  435.       h->fdec->i_ref[1] = h->i_ref[1];
  436.       for( int i = 0; i < h->i_ref[0]; i++ )
  437. >         h->fdec->ref_poc[0][i] = h->fref[0][i]->i_poc;
  438.       if( h->sh.i_type == SLICE_TYPE_B )
  439.       {
  440.   

common/macroblock.c:437: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fdec->ref_poc[0] of size 16 could be accessed with an index out of bounds at line 437, column 9
  435.       h->fdec->i_ref[1] = h->i_ref[1];
  436.       for( int i = 0; i < h->i_ref[0]; i++ )
  437. >         h->fdec->ref_poc[0][i] = h->fref[0][i]->i_poc;
  438.       if( h->sh.i_type == SLICE_TYPE_B )
  439.       {
  440.   

common/macroblock.c:565: error: ARRAY_OUT_OF_BOUNDS_L1
  array dst could be accessed with index -128 out of bounds at line 565, column 9
  563.       // input pointers are offset by 4 rows because that's faster (smaller instruction size on x86)
  564.       for( int i = -4; i < 4; i++ )
  565. >         dst[i*FDEC_STRIDE] = src[i*FDEC_STRIDE];
  566.   }
  567.   
  568.   

common/macroblock.c:565: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -128 out of bounds at line 565, column 30
  563.       // input pointers are offset by 4 rows because that's faster (smaller instruction size on x86)
  564.       for( int i = -4; i < 4; i++ )
  565. >         dst[i*FDEC_STRIDE] = src[i*FDEC_STRIDE];
  566.   }
  567.   
  568.   

common/mc.c:174: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>9)!=0) is always true at line 174, column 34
  172.                            intptr_t stride, int width, int height, int16_t *buf )
  173.   {
  174. >     const int pad = (BIT_DEPTH > 9) ? (-10 * PIXEL_MAX) : 0;
  175.       for( int y = 0; y < height; y++ )
  176.       {
  177.   

common/mc.c:179: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -2 out of bounds at line 179, column 21
  177.           for( int x = -2; x < width+3; x++ )
  178.           {
  179. >             int v = TAPFILTER(src,stride);
  180.               dstv[x] = x264_clip_pixel( (v + 16) >> 5 );
  181.               /* transform v for storage in a 16-bit integer */
  182.   

common/mc.c:180: warning: PRECONDITION_NOT_MET
  in call to x264_clip_pixel() at line 180, column 54
  178.           {
  179.               int v = TAPFILTER(src,stride);
  180. >             dstv[x] = x264_clip_pixel( (v + 16) >> 5 );
  181.               /* transform v for storage in a 16-bit integer */
  182.               buf[x+2] = v + pad;
  183.   

common/mc.c:426: error: ARRAY_OUT_OF_BOUNDS_L1
  array sum could be accessed with an index out of bounds at line 426, column 22
  424.       for( int x = 0; x < stride-4; x++ )
  425.       {
  426. >         sum[x] = v + sum[x-stride];
  427.           v += pix[x+4] - pix[x];
  428.       }
  429.   

common/mc.c:436: error: ARRAY_OUT_OF_BOUNDS_L1
  array sum could be accessed with an index out of bounds at line 436, column 22
  434.       for( int x = 0; x < stride-8; x++ )
  435.       {
  436. >         sum[x] = v + sum[x-stride];
  437.           v += pix[x+8] - pix[x];
  438.       }
  439.   

common/opencl.c:58: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 58, column 5
  56.   #undef fail
  57.   #define fail fail0
  58. >     CHECKED_MALLOCZERO( ocl, sizeof(x264_opencl_function_t) );
  59.   #undef fail
  60.   #define fail fail1
  61.   

common/opencl.c:125: warning: PRECONDITION_NOT_MET
  in call to fopen() at line 125, column 16
  123.   {
  124.       /* try to load cached program binary */
  125. >     FILE *fp = x264_fopen( h->param.psz_clbin_file, "rb" );
  126.       if( !fp )
  127.           return NULL;
  128.   

common/opencl.c:191: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 191, column 5
  189.       }
  190.   
  191. >     CHECKED_MALLOC( binary, size );
  192.       status = ocl->clGetProgramInfo( program, CL_PROGRAM_BINARIES, sizeof(uint8_t *), &binary, NULL );
  193.       if( status != CL_SUCCESS )
  194.   

common/opencl.c:559: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 559, column 5
  557.   
  558.   #define RELEASE( a, f ) do { if( a ) { ocl->f( a ); a = NULL; } } while( 0 )
  559. >     RELEASE( h->opencl.downscale_hpel_kernel, clReleaseKernel );
  560.       RELEASE( h->opencl.downscale_kernel1, clReleaseKernel );
  561.       RELEASE( h->opencl.downscale_kernel2, clReleaseKernel );
  562.   

common/opencl.c:560: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 560, column 5
  558.   #define RELEASE( a, f ) do { if( a ) { ocl->f( a ); a = NULL; } } while( 0 )
  559.       RELEASE( h->opencl.downscale_hpel_kernel, clReleaseKernel );
  560. >     RELEASE( h->opencl.downscale_kernel1, clReleaseKernel );
  561.       RELEASE( h->opencl.downscale_kernel2, clReleaseKernel );
  562.       RELEASE( h->opencl.weightp_hpel_kernel, clReleaseKernel );
  563.   

common/opencl.c:561: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 561, column 5
  559.       RELEASE( h->opencl.downscale_hpel_kernel, clReleaseKernel );
  560.       RELEASE( h->opencl.downscale_kernel1, clReleaseKernel );
  561. >     RELEASE( h->opencl.downscale_kernel2, clReleaseKernel );
  562.       RELEASE( h->opencl.weightp_hpel_kernel, clReleaseKernel );
  563.       RELEASE( h->opencl.weightp_scaled_images_kernel, clReleaseKernel );
  564.   

common/opencl.c:626: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 626, column 9
  624.   #define RELEASEBUF(mem) do { if( mem ) { ocl->clReleaseMemObject( mem ); mem = NULL; } } while( 0 )
  625.       for( int j = 0; j < NUM_IMAGE_SCALES; j++ )
  626. >         RELEASEBUF( frame->opencl.scaled_image2Ds[j] );
  627.       RELEASEBUF( frame->opencl.luma_hpel );
  628.       RELEASEBUF( frame->opencl.inv_qscale_factor );
  629.   

common/osdep.h:413: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 413, column 17
  411.       x264_struct_stat file_stat;
  412.       if( x264_stat( filename, &file_stat ) )
  413. >         return !x264_is_pipe( filename );
  414.       return S_ISREG( file_stat.st_mode );
  415.   }
  416.   

common/pixel.c:325: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 325, column 1
  323.       return sum;\
  324.   }
  325. > PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   

common/pixel.c:326: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 326, column 1
  324.   }
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326. > PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   

common/pixel.c:326: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 326, column 1
  324.   }
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326. > PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   

common/pixel.c:327: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 327, column 1
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327. > PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   

common/pixel.c:327: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 327, column 1
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327. > PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   

common/pixel.c:328: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 328, column 1
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328. > PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   

common/pixel.c:329: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 329, column 1
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329. > PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   

common/pixel.c:329: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((4==16)!=0) is always false at line 329, column 1
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329. > PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   

common/pixel.c:330: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((4==16)!=0) is always false at line 330, column 1
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330. > PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   static NOINLINE int sa8d_8x8( pixel *pix1, intptr_t i_pix1, pixel *pix2, intptr_t i_pix2 )
  333.   

common/pixel.c:330: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 330, column 1
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330. > PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   static NOINLINE int sa8d_8x8( pixel *pix1, intptr_t i_pix1, pixel *pix2, intptr_t i_pix2 )
  333.   

common/pixel.c:430: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 430, column 1
  428.       return ((sum>>34)<<32) + ((uint32_t)sum>>1);\
  429.   }
  430. > HADAMARD_AC( 16, 16 )
  431.   HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433.   

common/pixel.c:431: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 431, column 1
  429.   }
  430.   HADAMARD_AC( 16, 16 )
  431. > HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   

common/pixel.c:431: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 431, column 1
  429.   }
  430.   HADAMARD_AC( 16, 16 )
  431. > HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   

common/pixel.c:432: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 432, column 1
  430.   HADAMARD_AC( 16, 16 )
  431.   HADAMARD_AC( 16, 8 )
  432. > HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   
  435.   

common/pixel.c:432: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 432, column 1
  430.   HADAMARD_AC( 16, 16 )
  431.   HADAMARD_AC( 16, 8 )
  432. > HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   
  435.   

common/pixel.c:433: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 433, column 1
  431.   HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433. > HADAMARD_AC( 8, 8 )
  434.   
  435.   
  436.   

common/pixel.c:528: warning: PRECONDITION_NOT_MET
  in call to x264_10_predict_8x8_v_c() at line 528, column 1
  526.   }
  527.   
  528. > INTRA_MBCMP_8x8( sad,, _c )
  529.   INTRA_MBCMP_8x8(sa8d,, _c )
  530.   #if HIGH_BIT_DEPTH && HAVE_MMX
  531.   

common/pixel.c:529: warning: PRECONDITION_NOT_MET
  in call to x264_10_predict_8x8_v_c() at line 529, column 1
  527.   
  528.   INTRA_MBCMP_8x8( sad,, _c )
  529. > INTRA_MBCMP_8x8(sa8d,, _c )
  530.   #if HIGH_BIT_DEPTH && HAVE_MMX
  531.   #define x264_predict_8x8_v_sse2 x264_predict_8x8_v_sse
  532.   

common/pixel.c:532: warning: PRECONDITION_NOT_MET
  in call to x264_10_predict_8x8_v_c() at line 532, column 1
  530.   #if HIGH_BIT_DEPTH && HAVE_MMX
  531.   #define x264_predict_8x8_v_sse2 x264_predict_8x8_v_sse
  532. > INTRA_MBCMP_8x8( sad, _mmx2,  _c )
  533.   INTRA_MBCMP_8x8(sa8d, _sse2,  _sse2 )
  534.   #endif
  535.   

common/pixel.c:703: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 703, column 13
  701.           for( ; z <= y; z++ )
  702.           {
  703. >             XCHG( void*, sum0, sum1 );
  704.               for( int x = 0; x < width; x+=2 )
  705.                   pf->ssim_4x4x2_core( &pix1[4*(x+z*stride1)], stride1, &pix2[4*(x+z*stride2)], stride2, &sum0[x] );
  706.   

common/predict.c:70: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 70, column 15
  68.       for( int i = 0; i < 16; i++ )
  69.       {
  70. >         dc += src[-1 + i * FDEC_STRIDE];
  71.           dc += src[i - FDEC_STRIDE];
  72.       }
  73.   

common/predict.c:71: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 71, column 15
  69.       {
  70.           dc += src[-1 + i * FDEC_STRIDE];
  71. >         dc += src[i - FDEC_STRIDE];
  72.       }
  73.       pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 16 ) >> 5 );
  74.   

common/predict.c:82: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 82, column 15
  80.   
  81.       for( int i = 0; i < 16; i++ )
  82. >         dc += src[-1 + i * FDEC_STRIDE];
  83.       pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 8 ) >> 4 );
  84.   
  85.   

common/predict.c:92: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 92, column 15
  90.   
  91.       for( int i = 0; i < 16; i++ )
  92. >         dc += src[i - FDEC_STRIDE];
  93.       pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 8 ) >> 4 );
  94.   
  95.   

common/predict.c:105: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 105, column 26
  103.       for( int i = 0; i < 16; i++ )
  104.       {
  105. >         const pixel4 v = PIXEL_SPLAT_X4( src[-1] );
  106.           MPIXEL_X4( src+ 0 ) = v;
  107.           MPIXEL_X4( src+ 4 ) = v;
  108.   

common/predict.c:115: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 115, column 17
  113.   void x264_predict_16x16_v_c( pixel *src )
  114.   {
  115. >     pixel4 v0 = MPIXEL_X4( &src[ 0-FDEC_STRIDE] );
  116.       pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117.       pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118.   

common/predict.c:116: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 116, column 17
  114.   {
  115.       pixel4 v0 = MPIXEL_X4( &src[ 0-FDEC_STRIDE] );
  116. >     pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117.       pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118.       pixel4 v3 = MPIXEL_X4( &src[12-FDEC_STRIDE] );
  119.   

common/predict.c:117: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -24 out of bounds at line 117, column 17
  115.       pixel4 v0 = MPIXEL_X4( &src[ 0-FDEC_STRIDE] );
  116.       pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117. >     pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118.       pixel4 v3 = MPIXEL_X4( &src[12-FDEC_STRIDE] );
  119.   
  120.   

common/predict.c:118: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -20 out of bounds at line 118, column 17
  116.       pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117.       pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118. >     pixel4 v3 = MPIXEL_X4( &src[12-FDEC_STRIDE] );
  119.   
  120.       for( int i = 0; i < 16; i++ )
  121.   

common/predict.c:136: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -24 out of bounds at line 136, column 53
  134.       for( int i = 0; i <= 7; i++ )
  135.       {
  136. >         H += ( i + 1 ) * ( src[ 8 + i - FDEC_STRIDE ] - src[6 -i -FDEC_STRIDE] );
  137.           V += ( i + 1 ) * ( src[-1 + (8+i)*FDEC_STRIDE] - src[-1 + (6-i)*FDEC_STRIDE] );
  138.       }
  139.   

common/predict.c:179: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 179, column 16
  177.       for( int y = 0; y < 4; y++ )
  178.       {
  179. >         dc0 += src[y * FDEC_STRIDE     - 1];
  180.           dc1 += src[(y+4) * FDEC_STRIDE - 1];
  181.       }
  182.   

common/predict.c:205: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 205, column 16
  203.       for( int x = 0; x < 4; x++ )
  204.       {
  205. >         dc0 += src[x     - FDEC_STRIDE];
  206.           dc1 += src[x + 4 - FDEC_STRIDE];
  207.       }
  208.   

common/predict.c:206: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 206, column 16
  204.       {
  205.           dc0 += src[x     - FDEC_STRIDE];
  206. >         dc1 += src[x + 4 - FDEC_STRIDE];
  207.       }
  208.       pixel4 dc0splat = PIXEL_SPLAT_X4( ( dc0 + 2 ) >> 2 );
  209.   

common/predict.c:229: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 229, column 15
  227.       for( int i = 0; i < 4; i++ )
  228.       {
  229. >         s0 += src[i - FDEC_STRIDE];
  230.           s1 += src[i + 4 - FDEC_STRIDE];
  231.           s2 += src[-1 + i * FDEC_STRIDE];
  232.   

common/predict.c:230: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 230, column 15
  228.       {
  229.           s0 += src[i - FDEC_STRIDE];
  230. >         s1 += src[i + 4 - FDEC_STRIDE];
  231.           s2 += src[-1 + i * FDEC_STRIDE];
  232.           s3 += src[-1 + (i+4)*FDEC_STRIDE];
  233.   

common/predict.c:231: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 231, column 15
  229.           s0 += src[i - FDEC_STRIDE];
  230.           s1 += src[i + 4 - FDEC_STRIDE];
  231. >         s2 += src[-1 + i * FDEC_STRIDE];
  232.           s3 += src[-1 + (i+4)*FDEC_STRIDE];
  233.       }
  234.   

common/predict.c:261: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 261, column 20
  259.       for( int i = 0; i < 8; i++ )
  260.       {
  261. >         pixel4 v = PIXEL_SPLAT_X4( src[-1] );
  262.           MPIXEL_X4( src+0 ) = v;
  263.           MPIXEL_X4( src+4 ) = v;
  264.   

common/predict.c:285: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 285, column 49
  283.       for( int i = 0; i < 4; i++ )
  284.       {
  285. >         H += ( i + 1 ) * ( src[4+i - FDEC_STRIDE] - src[2 - i -FDEC_STRIDE] );
  286.           V += ( i + 1 ) * ( src[-1 +(i+4)*FDEC_STRIDE] - src[-1+(2-i)*FDEC_STRIDE] );
  287.       }
  288.   

common/predict.c:327: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 327, column 19
  325.   
  326.           for( int y = 0; y < 4; y++ )
  327. >             dc += src[y*FDEC_STRIDE - 1];
  328.   
  329.           pixel4 dcsplat = PIXEL_SPLAT_X4( (dc + 2) >> 2 );
  330.   

common/predict.c:345: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 345, column 16
  343.       for( int  x = 0; x < 4; x++ )
  344.       {
  345. >         dc0 += src[x     - FDEC_STRIDE];
  346.           dc1 += src[x + 4 - FDEC_STRIDE];
  347.       }
  348.   

common/predict.c:346: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 346, column 16
  344.       {
  345.           dc0 += src[x     - FDEC_STRIDE];
  346. >         dc1 += src[x + 4 - FDEC_STRIDE];
  347.       }
  348.       pixel4 dc0splat = PIXEL_SPLAT_X4( ( dc0 + 2 ) >> 2 );
  349.   

common/predict.c:371: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 371, column 15
  369.       for( int i = 0; i < 4; i++ )
  370.       {
  371. >         s0 += src[i+0 - FDEC_STRIDE];
  372.           s1 += src[i+4 - FDEC_STRIDE];
  373.           s2 += src[-1 + (i+0)  * FDEC_STRIDE];
  374.   

common/predict.c:372: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 372, column 15
  370.       {
  371.           s0 += src[i+0 - FDEC_STRIDE];
  372. >         s1 += src[i+4 - FDEC_STRIDE];
  373.           s2 += src[-1 + (i+0)  * FDEC_STRIDE];
  374.           s3 += src[-1 + (i+4)  * FDEC_STRIDE];
  375.   

common/predict.c:373: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 373, column 15
  371.           s0 += src[i+0 - FDEC_STRIDE];
  372.           s1 += src[i+4 - FDEC_STRIDE];
  373. >         s2 += src[-1 + (i+0)  * FDEC_STRIDE];
  374.           s3 += src[-1 + (i+4)  * FDEC_STRIDE];
  375.           s4 += src[-1 + (i+8)  * FDEC_STRIDE];
  376.   

common/predict.c:422: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 422, column 20
  420.       for( int i = 0; i < 16; i++ )
  421.       {
  422. >         pixel4 v = PIXEL_SPLAT_X4( src[-1] );
  423.           MPIXEL_X4( src+0 ) = v;
  424.           MPIXEL_X4( src+4 ) = v;
  425.   

common/predict.c:446: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 446, column 51
  444.   
  445.       for( int i = 0; i < 4; i++ )
  446. >         H += ( i + 1 ) * ( src[4 + i - FDEC_STRIDE] - src[2 - i - FDEC_STRIDE] );
  447.       for( int i = 0; i < 8; i++ )
  448.           V += ( i + 1 ) * ( src[-1 + (i+8)*FDEC_STRIDE] - src[-1 + (6-i)*FDEC_STRIDE] );
  449.   

common/predict.c:484: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 484, column 17
  482.   static void predict_4x4_dc_left_c( pixel *src )
  483.   {
  484. >     pixel4 dc = PIXEL_SPLAT_X4( (SRC(-1,0) + SRC(-1,1) + SRC(-1,2) + SRC(-1,3) + 2) >> 2 );
  485.       PREDICT_4x4_DC( dc );
  486.   }
  487.   

common/predict.c:489: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 489, column 17
  487.   static void predict_4x4_dc_top_c( pixel *src )
  488.   {
  489. >     pixel4 dc = PIXEL_SPLAT_X4( (SRC(0,-1) + SRC(1,-1) + SRC(2,-1) + SRC(3,-1) + 2) >> 2 );
  490.       PREDICT_4x4_DC( dc );
  491.   }
  492.   

common/predict.c:494: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 494, column 17
  492.   void x264_predict_4x4_dc_c( pixel *src )
  493.   {
  494. >     pixel4 dc = PIXEL_SPLAT_X4( (SRC(-1,0) + SRC(-1,1) + SRC(-1,2) + SRC(-1,3) +
  495.                                    SRC(0,-1) + SRC(1,-1) + SRC(2,-1) + SRC(3,-1) + 4) >> 3 );
  496.       PREDICT_4x4_DC( dc );
  497.   

common/predict.c:500: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 500, column 19
  498.   void x264_predict_4x4_h_c( pixel *src )
  499.   {
  500. >     SRC_X4(0,0) = PIXEL_SPLAT_X4( SRC(-1,0) );
  501.       SRC_X4(0,1) = PIXEL_SPLAT_X4( SRC(-1,1) );
  502.       SRC_X4(0,2) = PIXEL_SPLAT_X4( SRC(-1,2) );
  503.   

common/predict.c:507: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 507, column 5
  505.   void x264_predict_4x4_v_c( pixel *src )
  506.   {
  507. >     PREDICT_4x4_DC(SRC_X4(0,-1));
  508.   }
  509.   
  510.   

common/predict.c:533: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 533, column 5
  531.   static void predict_4x4_ddl_c( pixel *src )
  532.   {
  533. >     PREDICT_4x4_LOAD_TOP
  534.       PREDICT_4x4_LOAD_TOP_RIGHT
  535.       SRC(0,0)= F2(t0,t1,t2);
  536.   

common/predict.c:534: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 534, column 5
  532.   {
  533.       PREDICT_4x4_LOAD_TOP
  534. >     PREDICT_4x4_LOAD_TOP_RIGHT
  535.       SRC(0,0)= F2(t0,t1,t2);
  536.       SRC(1,0)=SRC(0,1)= F2(t1,t2,t3);
  537.   

common/predict.c:545: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 545, column 14
  543.   static void predict_4x4_ddr_c( pixel *src )
  544.   {
  545. >     int lt = SRC(-1,-1);
  546.       PREDICT_4x4_LOAD_LEFT
  547.       PREDICT_4x4_LOAD_TOP
  548.   

common/predict.c:546: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 546, column 5
  544.   {
  545.       int lt = SRC(-1,-1);
  546. >     PREDICT_4x4_LOAD_LEFT
  547.       PREDICT_4x4_LOAD_TOP
  548.       SRC(3,0)= F2(t3,t2,t1);
  549.   

common/predict.c:547: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 547, column 5
  545.       int lt = SRC(-1,-1);
  546.       PREDICT_4x4_LOAD_LEFT
  547. >     PREDICT_4x4_LOAD_TOP
  548.       SRC(3,0)= F2(t3,t2,t1);
  549.       SRC(2,0)=SRC(3,1)= F2(t2,t1,t0);
  550.   

common/predict.c:559: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 559, column 14
  557.   static void predict_4x4_vr_c( pixel *src )
  558.   {
  559. >     int lt = SRC(-1,-1);
  560.       PREDICT_4x4_LOAD_LEFT
  561.       PREDICT_4x4_LOAD_TOP
  562.   

common/predict.c:560: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 560, column 5
  558.   {
  559.       int lt = SRC(-1,-1);
  560. >     PREDICT_4x4_LOAD_LEFT
  561.       PREDICT_4x4_LOAD_TOP
  562.       SRC(0,3)= F2(l2,l1,l0);
  563.   

common/predict.c:561: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 561, column 5
  559.       int lt = SRC(-1,-1);
  560.       PREDICT_4x4_LOAD_LEFT
  561. >     PREDICT_4x4_LOAD_TOP
  562.       SRC(0,3)= F2(l2,l1,l0);
  563.       SRC(0,2)= F2(l1,l0,lt);
  564.   

common/predict.c:576: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 576, column 13
  574.   static void predict_4x4_hd_c( pixel *src )
  575.   {
  576. >     int lt= SRC(-1,-1);
  577.       PREDICT_4x4_LOAD_LEFT
  578.       PREDICT_4x4_LOAD_TOP
  579.   

common/predict.c:577: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 577, column 5
  575.   {
  576.       int lt= SRC(-1,-1);
  577. >     PREDICT_4x4_LOAD_LEFT
  578.       PREDICT_4x4_LOAD_TOP
  579.       SRC(0,3)= F1(l2,l3);
  580.   

common/predict.c:578: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 578, column 5
  576.       int lt= SRC(-1,-1);
  577.       PREDICT_4x4_LOAD_LEFT
  578. >     PREDICT_4x4_LOAD_TOP
  579.       SRC(0,3)= F1(l2,l3);
  580.       SRC(1,3)= F2(l1,l2,l3);
  581.   

common/predict.c:593: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 593, column 5
  591.   static void predict_4x4_vl_c( pixel *src )
  592.   {
  593. >     PREDICT_4x4_LOAD_TOP
  594.       PREDICT_4x4_LOAD_TOP_RIGHT
  595.       SRC(0,0)= F1(t0,t1);
  596.   

common/predict.c:594: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 594, column 5
  592.   {
  593.       PREDICT_4x4_LOAD_TOP
  594. >     PREDICT_4x4_LOAD_TOP_RIGHT
  595.       SRC(0,0)= F1(t0,t1);
  596.       SRC(0,1)= F2(t0,t1,t2);
  597.   

common/predict.c:609: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 609, column 5
  607.   static void predict_4x4_hu_c( pixel *src )
  608.   {
  609. >     PREDICT_4x4_LOAD_LEFT
  610.       SRC(0,0)= F1(l0,l1);
  611.       SRC(1,0)= F2(l0,l1,l2);
  612.   

common/predict.c:639: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 639, column 21
  637.       if( i_filters & MB_LEFT )
  638.       {
  639. >         edge[15] = (SRC(0,-1) + 2*SRC(-1,-1) + SRC(-1,0) + 2) >> 2;
  640.           edge[14] = ((have_lt ? SRC(-1,-1) : SRC(-1,0))
  641.                    + 2*SRC(-1,0) + SRC(-1,1) + 2) >> 2;
  642.   

common/predict.c:650: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 650, column 45
  648.       {
  649.           int have_tr = i_neighbor & MB_TOPRIGHT;
  650. >         edge[16] = ((have_lt ? SRC(-1,-1) : SRC(0,-1))
  651.                    + 2*SRC(0,-1) + SRC(1,-1) + 2) >> 2;
  652.           PT(1) PT(2) PT(3) PT(4) PT(5) PT(6)
  653.   

common/quant.c:60: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION
  A unary minus is applied to expression (((*bias[i]-*dct[i])**mf[i])>>16) of type unsigned int  at line 60, column 9
  58.       int nz = 0;
  59.       for( int i = 0; i < 64; i++ )
  60. >         QUANT_ONE( dct[i], mf[i], bias[i] );
  61.       return !!nz;
  62.   }
  63.   

common/quant.c:68: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION
  A unary minus is applied to expression (((*bias[i]-*dct[i])**mf[i])>>16) of type unsigned int  at line 68, column 9
  66.       int nz = 0;
  67.       for( int i = 0; i < 16; i++ )
  68. >         QUANT_ONE( dct[i], mf[i], bias[i] );
  69.       return !!nz;
  70.   }
  71.   

common/quant.c:79: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION
  A unary minus is applied to expression (((*bias[i]-*dct[j][i])**mf[i])>>16) of type unsigned int  at line 79, column 13
  77.           int nz = 0;
  78.           for( int i = 0; i < 16; i++ )
  79. >             QUANT_ONE( dct[j][i], mf[i], bias[i] );
  80.           nza |= (!!nz)<<j;
  81.       }
  82.   

common/set.c:308: warning: PRECONDITION_NOT_MET
  in call to strstr() at line 308, column 33
  306.       int i;
  307.   
  308. >     char *p = strstr( buf, name );
  309.       if( !p )
  310.       {
  311.   

common/set.c:361: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((35==0)!=0) is always false at line 361, column 17
  359.       }
  360.   
  361. >     while( (p = strchr( buf, '#' )) != NULL )
  362.           memset( p, ' ', strcspn( p, "\n" ) );
  363.   
  364.   

common/threadpool.c:86: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((0<0)!=0) is always false at line 86, column 9
  84.           return -1;
  85.   
  86. >     if( x264_threading_init() < 0 )
  87.           return -1;
  88.   
  89.   

common/threadpool.c:90: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 90, column 5
  88.   
  89.       x264_threadpool_t *pool;
  90. >     CHECKED_MALLOCZERO( pool, sizeof(x264_threadpool_t) );
  91.       *p_pool = pool;
  92.   
  93.   

common/threadpool.c:130: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 130, column 12
  128.   {
  129.       x264_pthread_mutex_lock( &pool->done.mutex );
  130. >     while( 1 )
  131.       {
  132.           for( int i = 0; i < pool->done.i_size; i++ )
  133.   

common/x86/predict-c.c:141: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>8)!=0) is always true at line 141, column 1
  139.   
  140.   #if HIGH_BIT_DEPTH
  141. > PREDICT_16x16_P_INLINE( sse2, sse2 )
  142.   #else // !HIGH_BIT_DEPTH
  143.   #if !ARCH_X86_64
  144.   

common/x86/predict-c.c:141: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 141, column 1
  139.   
  140.   #if HIGH_BIT_DEPTH
  141. > PREDICT_16x16_P_INLINE( sse2, sse2 )
  142.   #else // !HIGH_BIT_DEPTH
  143.   #if !ARCH_X86_64
  144.   

common/x86/predict-c.c:152: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>8)!=0) is always true at line 152, column 1
  150.   PREDICT_16x16_P_INLINE( avx, avx )
  151.   #endif // HIGH_BIT_DEPTH
  152. > PREDICT_16x16_P_INLINE( avx2, avx2 )
  153.   
  154.   #define PREDICT_8x16C_P_CORE\
  155.   

common/x86/predict-c.c:152: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 152, column 1
  150.   PREDICT_16x16_P_INLINE( avx, avx )
  151.   #endif // HIGH_BIT_DEPTH
  152. > PREDICT_16x16_P_INLINE( avx2, avx2 )
  153.   
  154.   #define PREDICT_8x16C_P_CORE\
  155.   

common/x86/predict-c.c:270: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 270, column 1
  268.   
  269.   #if HIGH_BIT_DEPTH
  270. > PREDICT_8x8C_P_INLINE( sse2, sse2 )
  271.   #else  //!HIGH_BIT_DEPTH
  272.   #if !ARCH_X86_64
  273.   

common/x86/predict-c.c:280: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 280, column 1
  278.   #endif // HAVE_X86_INLINE_ASM
  279.   #endif // HIGH_BIT_DEPTH
  280. > PREDICT_8x8C_P_INLINE( avx, avx )
  281.   PREDICT_8x8C_P_INLINE( avx2, avx2 )
  282.   
  283.   

common/x86/predict-c.c:281: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 281, column 1
  279.   #endif // HIGH_BIT_DEPTH
  280.   PREDICT_8x8C_P_INLINE( avx, avx )
  281. > PREDICT_8x8C_P_INLINE( avx2, avx2 )
  282.   
  283.   #if ARCH_X86_64 && !HIGH_BIT_DEPTH
  284.   

encoder/analyse.c:151: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 151, column 5
  149.       int lambda = x264_lambda_tab[qp];
  150.       /* factor of 4 from qpel, 2 from sign, and 2 because mv can be opposite from mvp */
  151. >     CHECKED_MALLOC( h->cost_mv[qp], (4*4*mv_range + 1) * sizeof(uint16_t) );
  152.       h->cost_mv[qp] += 2*4*mv_range;
  153.       for( int i = 0; i <= 2*4*mv_range; i++ )
  154.   

encoder/analyse.c:156: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->cost_mv[qp] last assigned on line 152 could be accessed with index -1 out of bounds at line 156, column 30
  154.       {
  155.           h->cost_mv[qp][-i] =
  156. >         h->cost_mv[qp][i]  = X264_MIN( (int)(lambda * logs[i] + .5f), UINT16_MAX );
  157.       }
  158.       for( int i = 0; i < 3; i++ )
  159.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][0] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][4] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][2] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][3] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][1] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][0] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][1] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][3] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][2] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][4] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:1262: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->mb.pic.p_fref[0][i_ref] of size 2 could be accessed with index 2 out of bounds at line 1262, column 9
  1260.   
  1261.           /* search with ref */
  1262. >         LOAD_HPELS( &m, h->mb.pic.p_fref[0][i_ref], 0, i_ref, 0, 0 );
  1263.           LOAD_WPELS( &m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 0, 0 );
  1264.   
  1265.   

encoder/analyse.c:1694: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_fref of size 2 last assigned on line 1675 could be accessed with an index out of bounds at line 1694, column 9
  1692.   
  1693.           LOAD_FENC( m, p_fenc, 4*x4, 4*y4 );
  1694. >         LOAD_HPELS( m, p_fref, 0, i_ref, 4*x4, 4*y4 );
  1695.           LOAD_WPELS( m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 4*x4, 4*y4 );
  1696.   
  1697.   

encoder/analyse.c:1733: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_fref of size 2 last assigned on line 1714 could be accessed with an index out of bounds at line 1733, column 9
  1731.   
  1732.           LOAD_FENC( m, p_fenc, 4*x4, 4*y4 );
  1733. >         LOAD_HPELS( m, p_fref, 0, i_ref, 4*x4, 4*y4 );
  1734.           LOAD_WPELS( m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 4*x4, 4*y4 );
  1735.   
  1736.   

encoder/analyse.c:1769: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_fref of size 2 last assigned on line 1750 could be accessed with an index out of bounds at line 1769, column 9
  1767.   
  1768.           LOAD_FENC( m, p_fenc, 4*x4, 4*y4 );
  1769. >         LOAD_HPELS( m, p_fref, 0, i_ref, 4*x4, 4*y4 );
  1770.           LOAD_WPELS( m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 4*x4, 4*y4 );
  1771.   
  1772.   

encoder/analyse.c:2146: warning: PRECONDITION_NOT_MET
  in call to x264_macroblock_cache_ref() at line 2146, column 9
  2144.       else
  2145.       {
  2146. >         CACHE_MV_BI( x, y, 2, 2, a->l0.me8x8[i], a->l1.me8x8[i], h->mb.i_sub_partition[i] );
  2147.       }
  2148.   }
  2149.   

encoder/analyse.c:2151: warning: PRECONDITION_NOT_MET
  in call to x264_macroblock_cache_ref() at line 2151, column 5
  2149.   static inline void mb_cache_mv_b16x8( x264_t *h, x264_mb_analysis_t *a, int i, int b_mvd )
  2150.   {
  2151. >     CACHE_MV_BI( 0, 2*i, 4, 2, a->l0.me16x8[i], a->l1.me16x8[i], a->i_mb_partition16x8[i] );
  2152.   }
  2153.   static inline void mb_cache_mv_b8x16( x264_t *h, x264_mb_analysis_t *a, int i, int b_mvd )
  2154.   

encoder/analyse.c:2155: warning: PRECONDITION_NOT_MET
  in call to x264_macroblock_cache_ref() at line 2155, column 5
  2153.   static inline void mb_cache_mv_b8x16( x264_t *h, x264_mb_analysis_t *a, int i, int b_mvd )
  2154.   {
  2155. >     CACHE_MV_BI( 2*i, 0, 2, 4, a->l0.me8x16[i], a->l1.me8x16[i], a->i_mb_partition8x16[i] );
  2156.   }
  2157.   #undef CACHE_MV_BI
  2158.   

encoder/analyse.c:2377: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->mb.pic.p_fref[l][i_ref] of size 2 could be accessed with an index out of bounds at line 2377, column 17
  2375.                   m.i_ref_cost = REF_COST( l, i_ref );
  2376.   
  2377. >                 LOAD_HPELS( &m, h->mb.pic.p_fref[l][i_ref], l, i_ref, 0, 8*i );
  2378.   
  2379.                   CP32( mvc[0], lX->mvc[i_ref][0] );
  2380.   

encoder/analyse.c:2471: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->mb.pic.p_fref[l][i_ref] of size 2 could be accessed with an index out of bounds at line 2471, column 17
  2469.                   m.i_ref_cost = REF_COST( l, i_ref );
  2470.   
  2471. >                 LOAD_HPELS( &m, h->mb.pic.p_fref[l][i_ref], l, i_ref, 8*i, 0 );
  2472.   
  2473.                   CP32( mvc[0], lX->mvc[i_ref][0] );
  2474.   

encoder/api.c:82: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 82, column 9
  80.           return NULL;
  81.   
  82. >     if( HAVE_BITDEPTH8 && param->i_bitdepth == 8 )
  83.       {
  84.           api->nal_encode = x264_8_nal_encode;
  85.   

encoder/api.c:97: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 97, column 14
  95.           api->x264 = x264_8_encoder_open( param );
  96.       }
  97. >     else if( HAVE_BITDEPTH10 && param->i_bitdepth == 10 )
  98.       {
  99.           api->nal_encode = x264_10_nal_encode;
  100.   

encoder/api.c:115: warning: UNINITIALIZED_VALUE
  value api->x264 was not initialized after declaration and is used at line 115, column 10
  113.           x264_log_internal( X264_LOG_ERROR, "not compiled with %d bit depth support\n", param->i_bitdepth );
  114.   
  115. >     if( !api->x264 )
  116.       {
  117.           free( api );
  118.   

encoder/cabac.c:360: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 360, column 13
  358.       {
  359.           case D_L0_8x8:
  360. >             cabac_mvd( h, cb, 0, 4*i, 2, 2 );
  361.               break;
  362.           case D_L0_8x4:
  363.   

encoder/cabac.c:363: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 363, column 13
  361.               break;
  362.           case D_L0_8x4:
  363. >             cabac_mvd( h, cb, 0, 4*i+0, 2, 1 );
  364.               cabac_mvd( h, cb, 0, 4*i+2, 2, 1 );
  365.               break;
  366.   

encoder/cabac.c:364: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 364, column 13
  362.           case D_L0_8x4:
  363.               cabac_mvd( h, cb, 0, 4*i+0, 2, 1 );
  364. >             cabac_mvd( h, cb, 0, 4*i+2, 2, 1 );
  365.               break;
  366.           case D_L0_4x8:
  367.   

encoder/cabac.c:367: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 367, column 13
  365.               break;
  366.           case D_L0_4x8:
  367. >             cabac_mvd( h, cb, 0, 4*i+0, 1, 2 );
  368.               cabac_mvd( h, cb, 0, 4*i+1, 1, 2 );
  369.               break;
  370.   

encoder/cabac.c:368: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 368, column 13
  366.           case D_L0_4x8:
  367.               cabac_mvd( h, cb, 0, 4*i+0, 1, 2 );
  368. >             cabac_mvd( h, cb, 0, 4*i+1, 1, 2 );
  369.               break;
  370.           case D_L0_4x4:
  371.   

encoder/cabac.c:716: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 716, column 13
  714.           }
  715.           else
  716. >             WRITE_SIGMAP( i, i )
  717.       }
  718.   
  719.   

encoder/cavlc.c:481: warning: PRECONDITION_NOT_MET
  in call to cavlc_mb_header_i() at line 481, column 53
  479.           bs_write1( s, 1 );
  480.       else //if( IS_INTRA( i_mb_type ) )
  481. >         cavlc_mb_header_i( h, i_mb_type, 23, chroma );
  482.   }
  483.   
  484.   

encoder/encoder.c:1354: warning: PRECONDITION_NOT_MET
  in call to memcpy() at line 1354, column 5
  1352.   {
  1353.       int satd = !h->mb.b_lossless && h->param.analyse.i_subpel_refine > 1;
  1354. >     memcpy( h->pixf.mbcmp, satd ? h->pixf.satd : h->pixf.sad_aligned, sizeof(h->pixf.mbcmp) );
  1355.       memcpy( h->pixf.mbcmp_unaligned, satd ? h->pixf.satd : h->pixf.sad, sizeof(h->pixf.mbcmp_unaligned) );
  1356.       h->pixf.intra_mbcmp_x3_16x16 = satd ? h->pixf.intra_satd_x3_16x16 : h->pixf.intra_sad_x3_16x16;
  1357.   

encoder/encoder.c:1455: warning: PRECONDITION_NOT_MET
  in call to x264_malloc() at line 1455, column 5
  1453.       int i_slicetype_length;
  1454.   
  1455. >     CHECKED_MALLOCZERO( h, sizeof(x264_t) );
  1456.   
  1457.       /* Create a copy of param */
  1458.   

encoder/encoder.c:2056: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 2056, column 21
  2054.       /* The reorder check doesn't check for missing frames, so just
  2055.        * force a reorder if one of the reference list is corrupt. */
  2056. >     for( int i = 0; h->frames.reference[i]; i++ )
  2057.           if( h->frames.reference[i]->b_corrupt )
  2058.           {
  2059.   

encoder/encoder.c:2057: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 2057, column 13
  2055.        * force a reorder if one of the reference list is corrupt. */
  2056.       for( int i = 0; h->frames.reference[i]; i++ )
  2057. >         if( h->frames.reference[i]->b_corrupt )
  2058.           {
  2059.               h->b_ref_reorder[0] = 1;
  2060.   

encoder/encoder.c:2065: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->fref[list] of size 2 could be accessed with index 2 out of bounds at line 2065, column 33
  2063.           for( int i = 0; i < h->i_ref[list] - 1; i++ )
  2064.           {
  2065. >             int framenum_diff = h->fref[list][i+1]->i_frame_num - h->fref[list][i]->i_frame_num;
  2066.               int poc_diff = h->fref[list][i+1]->i_poc - h->fref[list][i]->i_poc;
  2067.               /* P and B-frames use different default orders. */
  2068.   

encoder/encoder.c:2092: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>8)!=0) is always true at line 2092, column 9
  2090.        * With high bit depth, it's not worth doing, so turn it off except in the case of
  2091.        * unweighted dupes. */
  2092. >     if( BIT_DEPTH > 8 && w != x264_weight_none )
  2093.           return -1;
  2094.   
  2095.   

encoder/encoder.c:2120: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fenc->weighted of size 16 could be accessed with an index out of bounds at line 2120, column 68
  2118.       /* for now no analysis and set all weights to nothing */
  2119.       for( int i_ref = 0; i_ref < h->i_ref[0]; i_ref++ )
  2120. >         h->fenc->weighted[i_ref] = h->fref[0][i_ref]->filtered[0][0];
  2121.   
  2122.       // FIXME: This only supports weighting of one reference frame
  2123.   

encoder/encoder.c:2120: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->fref[0] of size 2 could be accessed with index 2 out of bounds at line 2120, column 52
  2118.       /* for now no analysis and set all weights to nothing */
  2119.       for( int i_ref = 0; i_ref < h->i_ref[0]; i_ref++ )
  2120. >         h->fenc->weighted[i_ref] = h->fref[0][i_ref]->filtered[0][0];
  2121.   
  2122.       // FIXME: This only supports weighting of one reference frame
  2123.   

encoder/encoder.c:2120: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fref[0] of size 2 could be accessed with an index out of bounds at line 2120, column 52
  2118.       /* for now no analysis and set all weights to nothing */
  2119.       for( int i_ref = 0; i_ref < h->i_ref[0]; i_ref++ )
  2120. >         h->fenc->weighted[i_ref] = h->fref[0][i_ref]->filtered[0][0];
  2121.   
  2122.       // FIXME: This only supports weighting of one reference frame
  2123.   

encoder/encoder.c:3215: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 3215, column 25
  3213.       if( pts >= h->i_last_idr_pts )
  3214.       {
  3215. >         for( int i = 0; h->frames.reference[i]; i++ )
  3216.               if( pts <= h->frames.reference[i]->i_pts )
  3217.                   h->frames.reference[i]->b_corrupt = 1;
  3218.   

encoder/encoder.c:3216: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 3216, column 24
  3214.       {
  3215.           for( int i = 0; h->frames.reference[i]; i++ )
  3216. >             if( pts <= h->frames.reference[i]->i_pts )
  3217.                   h->frames.reference[i]->b_corrupt = 1;
  3218.           if( pts <= h->fdec->i_pts )
  3219.   

encoder/encoder.c:4481: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 4481, column 31
  4479.       {
  4480.           for( int i = 0; i < h->i_thread_frames; i++ )
  4481. >             delayed_frames += h->thread[i]->b_thread_active;
  4482.           h = h->thread[h->i_thread_phase];
  4483.       }
  4484.   

encoder/lookahead.c:134: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 134, column 5
  132.   {
  133.       x264_lookahead_t *look;
  134. >     CHECKED_MALLOCZERO( look, sizeof(x264_lookahead_t) );
  135.       for( int i = 0; i < h->param.i_threads; i++ )
  136.           h->thread[i]->lookahead = look;
  137.   

encoder/lookahead.c:136: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 136, column 9
  134.       CHECKED_MALLOCZERO( look, sizeof(x264_lookahead_t) );
  135.       for( int i = 0; i < h->param.i_threads; i++ )
  136. >         h->thread[i]->lookahead = look;
  137.   
  138.       look->i_last_keyframe = - h->param.i_keyint_max;
  139.   

encoder/macroblock.c:569: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_dst could be accessed with index -1 out of bounds at line 569, column 36
  567.           h->mc.copy[PIXEL_4x4]( p_dst, FDEC_STRIDE, p_src-1, stride, 4 );
  568.           for( int i = 0; i < 4; i++ )
  569. >             p_dst[i*FDEC_STRIDE] = p_dst[i*FDEC_STRIDE-1];
  570.       }
  571.       else
  572.   

encoder/macroblock.c:609: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_dst last assigned on line 598 could be accessed with index -1 out of bounds at line 609, column 36
  607.           h->mc.copy_16x16_unaligned( p_dst, FDEC_STRIDE, h->mb.pic.p_fenc_plane[p]-1, stride, 16 );
  608.           for( int i = 0; i < 16; i++ )
  609. >             p_dst[i*FDEC_STRIDE] = p_dst[i*FDEC_STRIDE-1];
  610.       }
  611.       else
  612.   

encoder/me.c:219: warning: PRECONDITION_NOT_MET
  in call to x264_clip3() at line 219, column 78
  217.       {
  218.           /* Calculate and check the MVP first */
  219. >         int bpred_mx = x264_clip3( m->mvp[0], SPEL(mv_x_min), SPEL(mv_x_max) );
  220.           int bpred_my = x264_clip3( m->mvp[1], SPEL(mv_y_min), SPEL(mv_y_max) );
  221.           pmv = pack16to32_mask( bpred_mx, bpred_my );
  222.   

encoder/me.c:279: warning: PRECONDITION_NOT_MET
  in call to x264_clip3() at line 279, column 69
  277.       {
  278.           /* Calculate and check the fullpel MVP first */
  279. >         bmx = pmx = x264_clip3( FPEL(m->mvp[0]), mv_x_min, mv_x_max );
  280.           bmy = pmy = x264_clip3( FPEL(m->mvp[1]), mv_y_min, mv_y_max );
  281.           pmv = pack16to32_mask( bmx, bmy );
  282.   

encoder/ratecontrol.c:559: warning: UNINITIALIZED_VALUE
  value i_type was not initialized after declaration and is used at line 559, column 21
  557.                       goto fail;
  558.   
  559. >                 if( i_type != i_type_actual && rc->mbtree.qpbuf_pos == 1 )
  560.                   {
  561.                       x264_log( h, X264_LOG_ERROR, "MB-tree frametype %d doesn't match actual frametype %d.\n", i_type, i_type_actual );
  562.   

encoder/ratecontrol.c:1266: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 1266, column 9
  1264.       {
  1265.           char *psz_zones, *p;
  1266. >         CHECKED_MALLOC( psz_zones, strlen( h->param.rc.psz_zones )+1 );
  1267.           strcpy( psz_zones, h->param.rc.psz_zones );
  1268.           h->param.rc.i_zones = 1;
  1269.   

encoder/ratecontrol.c:1807: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1807, column 9
  1805.   
  1806.       if( rce->i_weight_denom[0] >= 0 )
  1807. >         SET_WEIGHT( frm->weight[0][0], 1, rce->weight[0][0], rce->i_weight_denom[0], rce->weight[0][1] );
  1808.   
  1809.       if( rce->i_weight_denom[1] >= 0 )
  1810.   

encoder/ratecontrol.c:1811: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1811, column 9
  1809.       if( rce->i_weight_denom[1] >= 0 )
  1810.       {
  1811. >         SET_WEIGHT( frm->weight[0][1], 1, rce->weight[1][0], rce->i_weight_denom[1], rce->weight[1][1] );
  1812.           SET_WEIGHT( frm->weight[0][2], 1, rce->weight[2][0], rce->i_weight_denom[1], rce->weight[2][1] );
  1813.       }
  1814.   

encoder/ratecontrol.c:1812: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1812, column 9
  1810.       {
  1811.           SET_WEIGHT( frm->weight[0][1], 1, rce->weight[1][0], rce->i_weight_denom[1], rce->weight[1][1] );
  1812. >         SET_WEIGHT( frm->weight[0][2], 1, rce->weight[2][0], rce->i_weight_denom[1], rce->weight[2][1] );
  1813.       }
  1814.   }
  1815.   

encoder/ratecontrol.c:2641: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 2641, column 22
  2639.       double totalsize = 0;
  2640.       for( int i = 0; i < h->param.i_threads; i++ )
  2641. >         totalsize += h->thread[i]->rc->slice_size_planned;
  2642.       double factor = h->rc->frame_size_planned / totalsize;
  2643.       for( int i = 0; i < h->param.i_threads; i++ )
  2644.   

encoder/ratecontrol.c:2642: error: DIVIDE_BY_ZERO
  Expression totalsize could be zero at line 2642, column 5
  2640.       for( int i = 0; i < h->param.i_threads; i++ )
  2641.           totalsize += h->thread[i]->rc->slice_size_planned;
  2642. >     double factor = h->rc->frame_size_planned / totalsize;
  2643.       for( int i = 0; i < h->param.i_threads; i++ )
  2644.           h->thread[i]->rc->slice_size_planned *= factor;
  2645.   

encoder/ratecontrol.c:2658: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 2658, column 25
  2656.           for( int i = 0; i < h->param.i_threads; i++ )
  2657.           {
  2658. >             x264_t *t = h->thread[i];
  2659.               if( t != h )
  2660.                   memcpy( t->rc->row_preds, rc->row_preds, sizeof(rc->row_preds) );
  2661.   

encoder/ratecontrol.c:2857: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 2857, column 5
  2855.       int iterations = 0;
  2856.       int adj_min, adj_max;
  2857. >     CHECKED_MALLOC( fills, (rcc->num_entries+1)*sizeof(double) );
  2858.   
  2859.       fills++;
  2860.   

encoder/ratecontrol.c:2881: error: ARRAY_OUT_OF_BOUNDS_L1
  array fills last assigned on line 2859 could be accessed with index -1 out of bounds at line 2881, column 75
  2879.           }
  2880.   
  2881. >         fills[-1] = rcc->buffer_size * (1. - h->param.rc.f_vbv_buffer_init);
  2882.           t0 = 0;
  2883.           /* fix underflows -- should be done after overflow, as we'd better undersize target than underflowing VBV */
  2884.   

encoder/rdo.c:583: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 583, column 5
  581.   {
  582.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  583. >     COEF( 1, 0, 0, 1, 1, 0 );
  584.       COEF( 1, 0, 1, 2, 2, 0 );
  585.       COEF( 1, 0, 2, 3, 3, 0 );
  586.   

encoder/rdo.c:584: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 584, column 5
  582.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  583.       COEF( 1, 0, 0, 1, 1, 0 );
  584. >     COEF( 1, 0, 1, 2, 2, 0 );
  585.       COEF( 1, 0, 2, 3, 3, 0 );
  586.       COEF( 1, 0, 3, 3, 4, 0 );
  587.   

encoder/rdo.c:585: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 585, column 5
  583.       COEF( 1, 0, 0, 1, 1, 0 );
  584.       COEF( 1, 0, 1, 2, 2, 0 );
  585. >     COEF( 1, 0, 2, 3, 3, 0 );
  586.       COEF( 1, 0, 3, 3, 4, 0 );
  587.       return levels_used;
  588.   

encoder/rdo.c:586: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 586, column 5
  584.       COEF( 1, 0, 1, 2, 2, 0 );
  585.       COEF( 1, 0, 2, 3, 3, 0 );
  586. >     COEF( 1, 0, 3, 3, 4, 0 );
  587.       return levels_used;
  588.   }
  589.   

encoder/rdo.c:597: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 597, column 5
  595.   {
  596.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  597. >     COEF( 1, 1, 1, 2, 2, 0 );
  598.       COEF( 1, 1, 2, 3, 3, 0 );
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600.   

encoder/rdo.c:598: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 598, column 5
  596.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  597.       COEF( 1, 1, 1, 2, 2, 0 );
  598. >     COEF( 1, 1, 2, 3, 3, 0 );
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601.   

encoder/rdo.c:599: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 599, column 5
  597.       COEF( 1, 1, 1, 2, 2, 0 );
  598.       COEF( 1, 1, 2, 3, 3, 0 );
  599. >     COEF( 1, 1, 3, 3, 4, 0 );
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602.   

encoder/rdo.c:600: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (4!=0) is always true at line 600, column 5
  598.       COEF( 1, 1, 2, 3, 3, 0 );
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600. >     COEF( 1, 1, 4, 4, 0, 0 );
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602.       COEF( 1, 1, 6, 6, 0, 0 );
  603.   

encoder/rdo.c:601: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (5!=0) is always true at line 601, column 5
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601. >     COEF( 1, 1, 5, 5, 0, 0 );
  602.       COEF( 1, 1, 6, 6, 0, 0 );
  603.       COEF( 1, 1, 7, 7, 0, 0 );
  604.   

encoder/rdo.c:602: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (6!=0) is always true at line 602, column 5
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602. >     COEF( 1, 1, 6, 6, 0, 0 );
  603.       COEF( 1, 1, 7, 7, 0, 0 );
  604.       return levels_used;
  605.   

encoder/rdo.c:603: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (7!=0) is always true at line 603, column 5
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602.       COEF( 1, 1, 6, 6, 0, 0 );
  603. >     COEF( 1, 1, 7, 7, 0, 0 );
  604.       return levels_used;
  605.   }
  606.   

encoder/rdo.c:615: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 615, column 5
  613.       int prefix = X264_MIN( abs_level-1, 14 );
  614.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  615. >     COEF( 2, 0, 0, 4, 1, 5 );
  616.       COEF( 2, 0, 1, 4, 2, 5 );
  617.       COEF( 2, 0, 2, 4, 3, 5 );
  618.   

encoder/rdo.c:616: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 616, column 5
  614.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  615.       COEF( 2, 0, 0, 4, 1, 5 );
  616. >     COEF( 2, 0, 1, 4, 2, 5 );
  617.       COEF( 2, 0, 2, 4, 3, 5 );
  618.       COEF( 2, 0, 3, 4, 4, 5 );
  619.   

encoder/rdo.c:617: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 617, column 5
  615.       COEF( 2, 0, 0, 4, 1, 5 );
  616.       COEF( 2, 0, 1, 4, 2, 5 );
  617. >     COEF( 2, 0, 2, 4, 3, 5 );
  618.       COEF( 2, 0, 3, 4, 4, 5 );
  619.       return levels_used;
  620.   

encoder/rdo.c:618: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 618, column 5
  616.       COEF( 2, 0, 1, 4, 2, 5 );
  617.       COEF( 2, 0, 2, 4, 3, 5 );
  618. >     COEF( 2, 0, 3, 4, 4, 5 );
  619.       return levels_used;
  620.   }
  621.   

encoder/rdo.c:630: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 630, column 5
  628.       int prefix = X264_MIN( abs_level-1, 14 );
  629.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  630. >     COEF( 2, 1, 1, 4, 2, 5 );
  631.       COEF( 2, 1, 2, 4, 3, 5 );
  632.       COEF( 2, 1, 3, 4, 4, 5 );
  633.   

encoder/rdo.c:631: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 631, column 5
  629.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  630.       COEF( 2, 1, 1, 4, 2, 5 );
  631. >     COEF( 2, 1, 2, 4, 3, 5 );
  632.       COEF( 2, 1, 3, 4, 4, 5 );
  633.       COEF( 2, 1, 4, 5, 0, 6 );
  634.   

encoder/rdo.c:632: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 632, column 5
  630.       COEF( 2, 1, 1, 4, 2, 5 );
  631.       COEF( 2, 1, 2, 4, 3, 5 );
  632. >     COEF( 2, 1, 3, 4, 4, 5 );
  633.       COEF( 2, 1, 4, 5, 0, 6 );
  634.       COEF( 2, 1, 5, 6, 0, 7 );
  635.   

encoder/rdo.c:633: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (4!=0) is always true at line 633, column 5
  631.       COEF( 2, 1, 2, 4, 3, 5 );
  632.       COEF( 2, 1, 3, 4, 4, 5 );
  633. >     COEF( 2, 1, 4, 5, 0, 6 );
  634.       COEF( 2, 1, 5, 6, 0, 7 );
  635.       COEF( 2, 1, 6, 7, 0, 8 );
  636.   

encoder/set.c:40: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 40, column 13
  38.       for( int i = 0; i < w; i++ )
  39.           for( int j = 0; j < i; j++ )
  40. >             XCHG( uint8_t, buf[w*i+j], buf[w*j+i] );
  41.   }
  42.   
  43.   

encoder/set.c:597: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 597, column 5
  595.       if( !opts )
  596.           return -1;
  597. >     CHECKED_MALLOC( payload, 200 + strlen( opts ) );
  598.   
  599.       memcpy( payload, uuid, 16 );
  600.   

encoder/set.c:602: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 602, column 40
  600.       sprintf( payload+16, "x264 - core %d%s - H.264/MPEG-4 AVC codec - "
  601.                "Copy%s 2003-2019 - http://www.videolan.org/x264.html - options: %s",
  602. >              X264_BUILD, X264_VERSION, HAVE_GPL?"left":"right", opts );
  603.       length = strlen(payload)+1;
  604.   
  605.   

encoder/slicetype-cl.c:67: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->opencl.copies of size 1024 could be accessed with an index out of bounds at line 67, column 17
  65.        * their final destination */
  66.       for( int i = 0; i < h->opencl.num_copies; i++ )
  67. >         memcpy( h->opencl.copies[i].dest, h->opencl.copies[i].src, h->opencl.copies[i].bytes );
  68.       h->opencl.num_copies = 0;
  69.       h->opencl.pl_occupancy = 0;
  70.   

encoder/slicetype-cl.c:572: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 572, column 5
  570.   
  571.       cl_uint arg = 0;
  572. >     OCLCHECK( clSetKernelArg, h->opencl.mode_select_kernel, arg++, sizeof(cl_mem), &fenc->opencl.scaled_image2Ds[0] );
  573.       OCLCHECK( clSetKernelArg, h->opencl.mode_select_kernel, arg++, sizeof(cl_mem), &fref0->opencl.luma_hpel );
  574.       OCLCHECK( clSetKernelArg, h->opencl.mode_select_kernel, arg++, sizeof(cl_mem), &fref1->opencl.luma_hpel );
  575.   

encoder/slicetype.c:291: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 291, column 5
  289.       const float epsilon = 1.f/128.f;
  290.       x264_weight_t *weights = fenc->weight[0];
  291. >     SET_WEIGHT( weights[0], 0, 1, 0, 0 );
  292.       SET_WEIGHT( weights[1], 0, 1, 0, 0 );
  293.       SET_WEIGHT( weights[2], 0, 1, 0, 0 );
  294.   

encoder/slicetype.c:292: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 292, column 5
  290.       x264_weight_t *weights = fenc->weight[0];
  291.       SET_WEIGHT( weights[0], 0, 1, 0, 0 );
  292. >     SET_WEIGHT( weights[1], 0, 1, 0, 0 );
  293.       SET_WEIGHT( weights[2], 0, 1, 0, 0 );
  294.       int chroma_initted = 0;
  295.   

encoder/slicetype.c:293: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 293, column 5
  291.       SET_WEIGHT( weights[0], 0, 1, 0, 0 );
  292.       SET_WEIGHT( weights[1], 0, 1, 0, 0 );
  293. >     SET_WEIGHT( weights[2], 0, 1, 0, 0 );
  294.       int chroma_initted = 0;
  295.       float guess_scale[3];
  296.   

encoder/slicetype.c:1404: error: DIVIDE_BY_ZERO
  Expression (h->param.i_keyint_max-h->param.i_keyint_min) could be zero at line 1404, column 9
  1402.       else
  1403.       {
  1404. >         f_bias = f_thresh_min
  1405.                    + ( f_thresh_max - f_thresh_min )
  1406.                    * ( i_gop_size - h->param.i_keyint_min )
  1407.   

filters/video/cache.c:68: error: MEMORY_LEAK
   memory dynamically allocated to return by call to calloc() at line 60, column 22 is not reachable after line 68, column 9
  66.       h->cache = malloc( (h->max_size+1) * sizeof(cli_pic_t*) );
  67.       if( !h->cache ) {
  68. >         return -1;
  69.       }
  70.   
  71.   

filters/video/cache.c:74: error: MEMORY_LEAK
   memory dynamically allocated to h by call to calloc() at line 60, column 22 is not reachable after line 74, column 29
  72.       {
  73.           h->cache[i] = malloc( sizeof(cli_pic_t) );
  74. >         if( !h->cache[i] || x264_cli_pic_alloc( h->cache[i], info->csp, info->width, info->height ) ) {
  75.               return -1; 
  76.           }
  77.   

filters/video/cache.c:127: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 127, column 5
  125.   {
  126.       cache_hnd_t *h = handle;
  127. >     FAIL_IF_ERR( frame < h->first_frame, NAME, "frame %d is before first cached frame %d \n", frame, h->first_frame );
  128.       fill_cache( h, frame );
  129.       if( frame > LAST_FRAME ) /* eof */
  130.   

filters/video/crop.c:56: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 56, column 9
  54.       {
  55.           char *opt = x264_get_option( optlist[i], opts );
  56. >         FAIL_IF_ERROR( !opt, "%s crop value not specified\n", optlist[i] );
  57.           h->dims[i] = x264_otoi( opt, -1 );
  58.           FAIL_IF_ERROR( h->dims[i] < 0, "%s crop value `%s' is less than 0\n", optlist[i], opt );
  59.   

filters/video/crop.c:57: warning: PRECONDITION_NOT_MET
  in call to x264_otoi() at line 57, column 22
  55.           char *opt = x264_get_option( optlist[i], opts );
  56.           FAIL_IF_ERROR( !opt, "%s crop value not specified\n", optlist[i] );
  57. >         h->dims[i] = x264_otoi( opt, -1 );
  58.           FAIL_IF_ERROR( h->dims[i] < 0, "%s crop value `%s' is less than 0\n", optlist[i], opt );
  59.           int dim_mod = i&1 ? (h->csp->mod_height << info->interlaced) : h->csp->mod_width;
  60.   

filters/video/crop.c:67: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 67, column 5
  65.   static int init( hnd_t *handle, cli_vid_filter_t *filter, video_info_t *info, x264_param_t *param, char *opt_string )
  66.   {
  67. >     FAIL_IF_ERROR( x264_cli_csp_is_invalid( info->csp ), "invalid csp %d\n", info->csp );
  68.       crop_hnd_t *h = calloc( 1, sizeof(crop_hnd_t) );
  69.       if( !h )
  70.   

filters/video/crop.c:81: error: MEMORY_LEAK
   memory dynamically allocated to return by call to calloc() at line 68, column 21 is not reachable after line 81, column 9
  79.       free( opts );
  80.       if( err )
  81. >         return -1;
  82.   
  83.       h->dims[2] = info->width  - h->dims[0] - h->dims[2];
  84.   

filters/video/crop.c:85: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 85, column 5
  83.       h->dims[2] = info->width  - h->dims[0] - h->dims[2];
  84.       h->dims[3] = info->height - h->dims[1] - h->dims[3];
  85. >     FAIL_IF_ERROR( h->dims[2] <= 0 || h->dims[3] <= 0, "invalid output resolution %dx%d\n", h->dims[2], h->dims[3] );
  86.   
  87.       if( info->width != h->dims[2] || info->height != h->dims[3] )
  88.   

filters/video/crop.c:85: error: MEMORY_LEAK
   memory dynamically allocated to h by call to calloc() at line 68, column 21 is not reachable after line 85, column 5
  83.       h->dims[2] = info->width  - h->dims[0] - h->dims[2];
  84.       h->dims[3] = info->height - h->dims[1] - h->dims[3];
  85. >     FAIL_IF_ERROR( h->dims[2] <= 0 || h->dims[3] <= 0, "invalid output resolution %dx%d\n", h->dims[2], h->dims[3] );
  86.   
  87.       if( info->width != h->dims[2] || info->height != h->dims[3] )
  88.   

filters/video/depth.c:218: warning: PRECONDITION_NOT_MET
  in call to x264_otoi() at line 218, column 25
  216.           {
  217.               char *str_bit_depth = x264_get_option( "bit_depth", opts );
  218. >             bit_depth = x264_otoi( str_bit_depth, -1 );
  219.   
  220.               ret = bit_depth < 8 || bit_depth > 16;
  221.   

filters/video/depth.c:229: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 229, column 5
  227.       }
  228.   
  229. >     FAIL_IF_ERROR( bit_depth != BIT_DEPTH, "this filter supports only bit depth %d\n", BIT_DEPTH );
  230.       FAIL_IF_ERROR( ret, "unsupported bit depth conversion.\n" );
  231.   
  232.   

filters/video/depth.c:230: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 230, column 5
  228.   
  229.       FAIL_IF_ERROR( bit_depth != BIT_DEPTH, "this filter supports only bit depth %d\n", BIT_DEPTH );
  230. >     FAIL_IF_ERROR( ret, "unsupported bit depth conversion.\n" );
  231.   
  232.       /* only add the filter to the chain if it's needed */
  233.   

filters/video/depth.c:235: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 235, column 9
  233.       if( change_fmt || bit_depth != 8 * x264_cli_csp_depth_factor( csp ) )
  234.       {
  235. >         FAIL_IF_ERROR( !depth_filter_csp_is_supported(csp), "unsupported colorspace.\n" );
  236.           depth_hnd_t *h = x264_malloc( sizeof(depth_hnd_t) + (info->width+1)*sizeof(int16_t) );
  237.   
  238.   

filters/video/internal.c:43: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 43, column 5
  41.   {
  42.       int csp = in->img.csp & X264_CSP_MASK;
  43. >     FAIL_IF_ERROR( x264_cli_csp_is_invalid( in->img.csp ), "invalid colorspace arg %d\n", in->img.csp );
  44.       FAIL_IF_ERROR( in->img.csp != out->img.csp || in->img.height != out->img.height
  45.                   || in->img.width != out->img.width, "incompatible frame properties\n" );
  46.   

filters/video/internal.c:44: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 44, column 5
  42.       int csp = in->img.csp & X264_CSP_MASK;
  43.       FAIL_IF_ERROR( x264_cli_csp_is_invalid( in->img.csp ), "invalid colorspace arg %d\n", in->img.csp );
  44. >     FAIL_IF_ERROR( in->img.csp != out->img.csp || in->img.height != out->img.height
  45.                   || in->img.width != out->img.width, "incompatible frame properties\n" );
  46.       /* copy data */
  47.   

filters/video/select_every.c:68: warning: PRECONDITION_NOT_MET
  in call to x264_otoi() at line 68, column 38
  66.       for( char *tok, *p = opt_string, UNUSED *saveptr = NULL; (tok = strtok_r( p, ",", &saveptr )); p = NULL )
  67.       {
  68. >         int val = x264_otoi( tok, -1 );
  69.           if( p )
  70.           {
  71.   

filters/video/select_every.c:79: error: MEMORY_LEAK
   memory dynamically allocated by call to malloc() at line 60, column 52 is not reachable after line 79, column 5
  77.           offsets[h->pattern_len++] = val;
  78.       }
  79. >     FAIL_IF_ERROR( !h->step_size, "no step size provided\n" );
  80.       FAIL_IF_ERROR( !h->pattern_len, "no offsets supplied\n" );
  81.   
  82.   

filters/video/source.c:49: error: MEMORY_LEAK
   memory dynamically allocated to return by call to calloc() at line 42, column 23 is not reachable after line 49, column 9
  47.   
  48.       if( cli_input.picture_alloc( &h->pic, *handle, info->csp, info->width, info->height ) ) {
  49. >         return -1;
  50.       }
  51.   
  52.   

filters/video/video.c:51: warning: PRECONDITION_NOT_MET
  in call to register_vid_filter() at line 51, column 5
  49.   #if HAVE_BITDEPTH8
  50.       REGISTER_VFILTER( cache_8 );
  51. >     REGISTER_VFILTER( depth_8 );
  52.   #endif
  53.   #if HAVE_BITDEPTH10
  54.   

filters/video/video.c:71: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 71, column 5
  69.       while( filter_i && strcasecmp( name, filter_i->name ) )
  70.           filter_i = filter_i->next;
  71. >     FAIL_IF_ERR( !filter_i, "x264", "invalid filter `%s'\n", name );
  72.       if( filter_i->init( handle, filter, info, param, opt_string ) )
  73.           return -1;
  74.   

input/avs.c:134: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 134, column 5
  132.       if( !h->library )
  133.           return -1;
  134. >     LOAD_AVS_FUNC( avs_clip_get_error, 0 );
  135.       LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.   

input/avs.c:135: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 135, column 5
  133.           return -1;
  134.       LOAD_AVS_FUNC( avs_clip_get_error, 0 );
  135. >     LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138.   

input/avs.c:136: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 136, column 5
  134.       LOAD_AVS_FUNC( avs_clip_get_error, 0 );
  135.       LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136. >     LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.   

input/avs.c:137: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 137, column 5
  135.       LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137. >     LOAD_AVS_FUNC( avs_get_error, 1 );
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.       LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140.   

input/avs.c:138: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 138, column 5
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138. >     LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.       LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140.       LOAD_AVS_FUNC( avs_function_exists, 0 );
  141.   

input/avs.c:139: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 139, column 5
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139. >     LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140.       LOAD_AVS_FUNC( avs_function_exists, 0 );
  141.       LOAD_AVS_FUNC( avs_invoke, 0 );
  142.   

input/avs.c:140: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 140, column 5
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.       LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140. >     LOAD_AVS_FUNC( avs_function_exists, 0 );
  141.       LOAD_AVS_FUNC( avs_invoke, 0 );
  142.       LOAD_AVS_FUNC( avs_release_clip, 0 );
  143.   

input/avs.c:225: warning: ARRAY_OUT_OF_BOUNDS_L2
  array all_purpose of size 2 could be accessed with an index out of bounds at line 225, column 21
  223.           filter[i++] = "AVCSource";
  224.   #endif
  225. >     for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226.           filter[i++] = all_purpose[j];
  227.   }
  228.   

input/avs.c:225: error: ARRAY_OUT_OF_BOUNDS_L1
  array all_purpose of size 2 could be accessed with an index out of bounds at line 225, column 21
  223.           filter[i++] = "AVCSource";
  224.   #endif
  225. >     for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226.           filter[i++] = all_purpose[j];
  227.   }
  228.   

input/avs.c:226: error: ARRAY_OUT_OF_BOUNDS_L1
  array all_purpose of size 2 could be accessed with an index out of bounds at line 226, column 23
  224.   #endif
  225.       for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226. >         filter[i++] = all_purpose[j];
  227.   }
  228.   
  229.   

input/avs.c:226: warning: ARRAY_OUT_OF_BOUNDS_L2
  array all_purpose of size 2 could be accessed with an index out of bounds at line 226, column 23
  224.   #endif
  225.       for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226. >         filter[i++] = all_purpose[j];
  227.   }
  228.   
  229.   

input/avs.c:265: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 265, column 5
  263.       int b_regular = x264_is_regular_file( fh );
  264.       fclose( fh );
  265. >     FAIL_IF_ERROR( !b_regular, "AVS input is incompatible with non-regular file `%s'\n", psz_filename );
  266.   
  267.       avs_hnd_t *h = calloc( 1, sizeof(avs_hnd_t) );
  268.   

input/avs.c:272: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 272, column 5
  270.       }
  271.       __efffix_tmp = custom_avs_load_library( h );
  272. >     FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273.       h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.   

input/avs.c:272: error: MEMORY_LEAK
   memory dynamically allocated by call to calloc() at line 267, column 20 is not reachable after line 272, column 5
  270.       }
  271.       __efffix_tmp = custom_avs_load_library( h );
  272. >     FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273.       h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.   

input/avs.c:273: warning: UNINITIALIZED_VALUE
  value h->func.avs_create_script_environment was not initialized after declaration and is used at line 273, column 14
  271.       __efffix_tmp = custom_avs_load_library( h );
  272.       FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273. >     h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.       {
  276.   

input/avs.c:273: error: DANGLING_POINTER_DEREFERENCE
  uninitialized pointer h->func.avs_create_script_environment could be dangling and is dereferenced or freed at line 273, column 14
  271.       __efffix_tmp = custom_avs_load_library( h );
  272.       FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273. >     h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.       {
  276.   

input/avs.c:515: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 515, column 5
  513.       AVS_VideoFrame *frm = pic->opaque = h->func.avs_get_frame( h->clip, i_frame );
  514.       const char *err = h->func.avs_clip_get_error( h->clip );
  515. >     FAIL_IF_ERROR( err, "%s occurred while reading frame %d\n", err, i_frame );
  516.       for( int i = 0; i < pic->img.planes; i++ )
  517.       {
  518.   

input/input.c:138: warning: ARRAY_OUT_OF_BOUNDS_L2
  array pic->img.plane of size 4 could be accessed with an index out of bounds at line 138, column 20
  136.   {
  137.       for( int i = 0; i < pic->img.planes; i++ )
  138. >         x264_free( pic->img.plane[i] );
  139.       memset( pic, 0, sizeof(cli_pic_t) );
  140.   }
  141.   

input/raw.c:45: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 45, column 49
  43.   static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
  44.   {
  45. >     raw_hnd_t *h = calloc( 1, sizeof(raw_hnd_t) );
  46.       if( !h )
  47.           return -1;
  48.   

input/thread.c:56: error: MEMORY_LEAK
   memory dynamically allocated to h by call to malloc() at line 54, column 23 is not reachable after line 56, column 5
  54.       thread_hnd_t *h = malloc( sizeof(thread_hnd_t) );
  55.       __efffix_tmp = cli_input.picture_alloc( &h->pic, *p_handle, info->csp, info->width, info->height );
  56. >     FAIL_IF_ERR( !h || __efffix_tmp,
  57.                    "x264", "malloc failed\n" );
  58.       h->input = cli_input;
  59.   

input/thread.c:56: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 56, column 5
  54.       thread_hnd_t *h = malloc( sizeof(thread_hnd_t) );
  55.       __efffix_tmp = cli_input.picture_alloc( &h->pic, *p_handle, info->csp, info->width, info->height );
  56. >     FAIL_IF_ERR( !h || __efffix_tmp,
  57.                    "x264", "malloc failed\n" );
  58.       h->input = cli_input;
  59.   

input/thread.c:63: error: MEMORY_LEAK
   memory dynamically allocated to return by call to malloc() at line 54, column 23 is not reachable after line 63, column 9
  61.       h->next_args = malloc( sizeof(thread_input_arg_t) );
  62.       if( !h->next_args ) {
  63. >         return -1;
  64.       }
  65.       h->next_args->h = h;
  66.   

input/thread.c:69: warning: PRECONDITION_NOT_MET
  in call to x264_10_threadpool_init() at line 69, column 9
  67.       h->frame_total = info->num_frames;
  68.   
  69. >     if( x264_threadpool_init( &h->pool, 1, NULL, NULL ) ) {
  70.           return -1;
  71.       }
  72.   

input/timecode.c:60: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 60, column 12
  58.       double exponent;
  59.       double fps_sig = sigexp10( fps, &exponent );
  60. >     while( 1 )
  61.       {
  62.           fps_den = i * h->timebase_num;
  63.   

input/timecode.c:64: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 64, column 9
  62.           fps_den = i * h->timebase_num;
  63.           fps_num = round( fps_den * fps_sig ) * exponent;
  64. >         FAIL_IF_ERROR( fps_num > UINT32_MAX, "tcfile fps correction failed.\n"
  65.                          "                  Specify an appropriate timebase manually or remake tcfile.\n" );
  66.           if( fabs( ((double)fps_num / fps_den) / exponent - fps_sig ) < DOUBLE_EPSILON )
  67.   

input/timecode.c:90: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 90, column 9
  88.           fps_den = round( MKV_TIMEBASE_DEN / fps_sig ) / exponent;
  89.           h->timebase_num = fps_den && h->timebase_num ? gcd( h->timebase_num, fps_den ) : fps_den;
  90. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || !h->timebase_num, "automatic timebase generation failed.\n"
  91.                          "                  Specify timebase manually.\n" );
  92.       }
  93.   

input/timecode.c:104: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 104, column 5
  102.   
  103.       ret = fscanf( tcfile_in, "# timecode format v%d", &tcfv );
  104. >     FAIL_IF_ERROR( ret != 1 || (tcfv != 1 && tcfv != 2), "unsupported timecode format\n" );
  105.   #define NO_TIMECODE_LINE (buff[0] == '#' || buff[0] == '\n' || buff[0] == '\r')
  106.       if( tcfv == 1 )
  107.   

input/timecode.c:348: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 348, column 5
  346.       FILE *tcfile_in;
  347.       timecode_hnd_t *h = malloc( sizeof(timecode_hnd_t) );
  348. >     FAIL_IF_ERROR( !h, "malloc failed\n" );
  349.       h->input = cli_input;
  350.       h->p_handle = *p_handle;
  351.   

input/timecode.c:360: warning: UNINITIALIZED_VALUE
  value h->timebase_den was not initialized after declaration and is used at line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/timecode.c:360: error: MEMORY_LEAK
   memory dynamically allocated to h by call to malloc() at line 347, column 56 is not reachable after line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/timecode.c:360: warning: UNINITIALIZED_VALUE
  value h->timebase_num was not initialized after declaration and is used at line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/timecode.c:360: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/y4m.c:73: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 73, column 20
  71.   static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
  72.   {
  73. >     y4m_hnd_t *h = calloc( 1, sizeof(y4m_hnd_t) );
  74.       int i;
  75.       uint32_t n, d;
  76.   

input/y4m.c:269: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 269, column 9
  267.           while( i <= MAX_FRAME_HEADER && fgetc( h->fh ) != '\n' )
  268.               i++;
  269. >         FAIL_IF_ERROR( i > MAX_FRAME_HEADER, "bad frame header length\n" );
  270.       }
  271.       FAIL_IF_ERROR( memcmp( header, Y4M_FRAME_MAGIC, slen ), "bad frame header magic\n" );
  272.   

output/flv.c:156: warning: PRECONDITION_NOT_MET
  in call to flv_rewrite_amf_be24() at line 156, column 5
  154.   
  155.       unsigned length = c->d_cur - start;
  156. >     flv_rewrite_amf_be24( c, length - 10, start );
  157.   
  158.       flv_put_be32( c, length + 1 ); // tag length
  159.   

output/flv.c:222: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 222, column 5
  220.       flv_rewrite_amf_be24( c, length, p_flv->start - 10 );
  221.       flv_put_be32( c, length + 11 ); // Last tag size
  222. >     CHECK( flv_flush_data( c ) );
  223.   
  224.       return sei_size + sps_size + pps_size;
  225.   

output/flv.c:323: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 323, column 5
  321.       flv_buffer *c = p_flv->c;
  322.   
  323. >     CHECK( flv_flush_data( c ) );
  324.   
  325.       double total_duration;
  326.   

output/flv_bytestream.c:90: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 90, column 21
  88.   flv_buffer *flv_create_writer( const char *filename )
  89.   {
  90. >     flv_buffer *c = calloc( 1, sizeof(flv_buffer) );
  91.       if( !c )
  92.           return NULL;
  93.   

output/matroska_ebml.c:168: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 168, column 5
  166.           return 0;
  167.   
  168. >     CHECK( mk_write_id( c->parent, c->id ) );
  169.       CHECK( mk_append_context_data( c->parent, &ff, 1 ) );
  170.   
  171.   

output/matroska_ebml.c:169: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 169, column 5
  167.   
  168.       CHECK( mk_write_id( c->parent, c->id ) );
  169. >     CHECK( mk_append_context_data( c->parent, &ff, 1 ) );
  170.   
  171.       c->id = 0;
  172.   

output/matroska_ebml.c:182: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 182, column 9
  180.   
  181.       if( c->parent )
  182. >         CHECK( mk_append_context_data( c->parent, c->data, c->d_cur ) );
  183.       else if( fwrite( c->data, c->d_cur, 1, c->owner->fp ) != 1 )
  184.           return -1;
  185.   

output/matroska_ebml.c:195: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 195, column 9
  193.       if( c->id )
  194.       {
  195. >         CHECK( mk_write_id( c->parent, c->id ) );
  196.           CHECK( mk_write_size( c->parent, c->d_cur ) );
  197.       }
  198.   

output/matroska_ebml.c:196: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 196, column 9
  194.       {
  195.           CHECK( mk_write_id( c->parent, c->id ) );
  196. >         CHECK( mk_write_size( c->parent, c->d_cur ) );
  197.       }
  198.   
  199.   

output/matroska_ebml.c:238: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 238, column 5
  236.       size_t len = strlen( str );
  237.   
  238. >     CHECK( mk_write_id( c, id ) );
  239.       CHECK( mk_write_size( c, len ) );
  240.       CHECK( mk_append_context_data( c, str, len ) );
  241.   

output/matroska_ebml.c:239: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 239, column 5
  237.   
  238.       CHECK( mk_write_id( c, id ) );
  239. >     CHECK( mk_write_size( c, len ) );
  240.       CHECK( mk_append_context_data( c, str, len ) );
  241.       return 0;
  242.   

output/matroska_ebml.c:240: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 240, column 5
  238.       CHECK( mk_write_id( c, id ) );
  239.       CHECK( mk_write_size( c, len ) );
  240. >     CHECK( mk_append_context_data( c, str, len ) );
  241.       return 0;
  242.   }
  243.   

output/matroska_ebml.c:246: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 246, column 5
  244.   static int mk_write_bin( mk_context *c, unsigned id, const void *data, unsigned size )
  245.   {
  246. >     CHECK( mk_write_id( c, id ) );
  247.       CHECK( mk_write_size( c, size ) );
  248.       CHECK( mk_append_context_data( c, data, size ) );
  249.   

output/matroska_ebml.c:247: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 247, column 5
  245.   {
  246.       CHECK( mk_write_id( c, id ) );
  247. >     CHECK( mk_write_size( c, size ) );
  248.       CHECK( mk_append_context_data( c, data, size ) );
  249.       return 0;
  250.   

output/matroska_ebml.c:248: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 248, column 5
  246.       CHECK( mk_write_id( c, id ) );
  247.       CHECK( mk_write_size( c, size ) );
  248. >     CHECK( mk_append_context_data( c, data, size ) );
  249.       return 0;
  250.   }
  251.   

output/matroska_ebml.c:257: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 257, column 5
  255.       unsigned i = 0;
  256.   
  257. >     CHECK( mk_write_id( c, id ) );
  258.       while( i < 7 && !c_ui[i] )
  259.           ++i;
  260.   

output/matroska_ebml.c:275: warning: UNINITIALIZED_VALUE
  value u.u was not initialized after declaration and is used at line 275, column 14
  273.   
  274.       u.f = f;
  275. >     c_f[0] = u.u >> 24;
  276.       c_f[1] = u.u >> 16;
  277.       c_f[2] = u.u >> 8;
  278.   

output/matroska_ebml.c:285: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 285, column 5
  283.   static int mk_write_float( mk_context *c, unsigned id, float f )
  284.   {
  285. >     CHECK( mk_write_id( c, id ) );
  286.       CHECK( mk_write_size( c, 4 ) );
  287.       CHECK( mk_write_float_raw( c, f ) );
  288.   

output/matroska_ebml.c:286: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 286, column 5
  284.   {
  285.       CHECK( mk_write_id( c, id ) );
  286. >     CHECK( mk_write_size( c, 4 ) );
  287.       CHECK( mk_write_float_raw( c, f ) );
  288.       return 0;
  289.   

output/matroska_ebml.c:287: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 287, column 5
  285.       CHECK( mk_write_id( c, id ) );
  286.       CHECK( mk_write_size( c, 4 ) );
  287. >     CHECK( mk_write_float_raw( c, f ) );
  288.       return 0;
  289.   }
  290.   

output/matroska_ebml.c:293: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 293, column 20
  291.   mk_writer *mk_create_writer( const char *filename )
  292.   {
  293. >     mk_writer *w = calloc( 1, sizeof(mk_writer) );
  294.       if( !w )
  295.           return NULL;
  296.   

output/matroska_ebml.c:338: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 338, column 5
  336.       if( !(c = mk_create_context( w, w->root, 0x1a45dfa3 )) ) // EBML
  337.           return -1;
  338. >     CHECK( mk_write_uint( c, 0x4286, 1 ) ); // EBMLVersion
  339.       CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.   

output/matroska_ebml.c:339: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 339, column 5
  337.           return -1;
  338.       CHECK( mk_write_uint( c, 0x4286, 1 ) ); // EBMLVersion
  339. >     CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.       CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342.   

output/matroska_ebml.c:340: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 340, column 5
  338.       CHECK( mk_write_uint( c, 0x4286, 1 ) ); // EBMLVersion
  339.       CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340. >     CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.       CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342.       CHECK( mk_write_string( c, 0x4282, "matroska") ); // DocType
  343.   

output/matroska_ebml.c:341: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 341, column 5
  339.       CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341. >     CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342.       CHECK( mk_write_string( c, 0x4282, "matroska") ); // DocType
  343.       CHECK( mk_write_uint( c, 0x4287, stereo_mode >= 0 ? 3 : 2 ) ); // DocTypeVersion
  344.   

output/matroska_ebml.c:342: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 342, column 5
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.       CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342. >     CHECK( mk_write_string( c, 0x4282, "matroska") ); // DocType
  343.       CHECK( mk_write_uint( c, 0x4287, stereo_mode >= 0 ? 3 : 2 ) ); // DocTypeVersion
  344.       CHECK( mk_write_uint( c, 0x4285, 2 ) ); // DocTypeReadVersion
  345.   

output/matroska_ebml.c:401: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 401, column 5
  399.       if( w->cluster == NULL )
  400.           return 0;
  401. >     CHECK( mk_close_context( w->cluster, 0 ) );
  402.       w->cluster = NULL;
  403.       CHECK( mk_flush_context_data( w->root ) );
  404.   

output/matroska_ebml.c:403: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 403, column 5
  401.       CHECK( mk_close_context( w->cluster, 0 ) );
  402.       w->cluster = NULL;
  403. >     CHECK( mk_flush_context_data( w->root ) );
  404.       return 0;
  405.   }
  406.   

output/matroska_ebml.c:418: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 418, column 9
  416.       delta = w->frame_tc/w->timescale - w->cluster_tc_scaled;
  417.       if( delta > 32767ll || delta < -32768ll )
  418. >         CHECK( mk_close_cluster( w ) );
  419.   
  420.       if( !w->cluster )
  421.   

x264.c:1421: warning: UNINITIALIZED_VALUE
  value defaults.i_log_level was not initialized after declaration and is used at line 1421, column 21
  1419.   
  1420.       x264_param_default( &defaults );
  1421. >     cli_log_level = defaults.i_log_level;
  1422.   
  1423.       memset( &input_opt, 0, sizeof(cli_input_opt_t) );
  1424.   

x264.c:1857: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 1857, column 5
  1855.       i_frame_size = x264_encoder_encode( h, &nal, &i_nal, pic, &pic_out );
  1856.   
  1857. >     FAIL_IF_ERROR( i_frame_size < 0, "x264_encoder_encode failed\n" );
  1858.   
  1859.       if( i_frame_size )
  1860.   

x264.c:1861: warning: UNINITIALIZED_VALUE
  value nal was not initialized after declaration and is used at line 1861, column 54
  1859.       if( i_frame_size )
  1860.       {
  1861. >         i_frame_size = cli_output.write_frame( hout, nal[0].p_payload, i_frame_size, &pic_out );
  1862.           *last_dts = pic_out.i_dts;
  1863.       }
  1864.   

x264.c:1861: error: DANGLING_POINTER_DEREFERENCE
  uninitialized pointer nal could be dangling and is dereferenced or freed at line 1861, column 54
  1859.       if( i_frame_size )
  1860.       {
  1861. >         i_frame_size = cli_output.write_frame( hout, nal[0].p_payload, i_frame_size, &pic_out );
  1862.           *last_dts = pic_out.i_dts;
  1863.       }
  1864.   

x264.c:1949: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 1949, column 9
  1947.           pulldown = &pulldown_values[opt->i_pulldown];
  1948.           param->i_timebase_num = param->i_fps_den;
  1949. >         FAIL_IF_ERROR2( fmod( param->i_fps_num * pulldown->fps_factor, 1 ),
  1950.                           "unsupported framerate for chosen pulldown\n" );
  1951.           param->i_timebase_den = param->i_fps_num * pulldown->fps_factor;
  1952.   

x264cli.h:50: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 50, column 12
  48.   static inline uint64_t gcd( uint64_t a, uint64_t b )
  49.   {
  50. >     while( 1 )
  51.       {
  52.           int64_t c = a % b;
  53.   

Summary of the reports

                      CONDITION_ALWAYS_FALSE: 103
                      ARRAY_OUT_OF_BOUNDS_L1: 84
                       CONDITION_ALWAYS_TRUE: 43
                        PRECONDITION_NOT_MET: 26
                      ARRAY_OUT_OF_BOUNDS_L2: 16
                                 MEMORY_LEAK: 10
                         UNINITIALIZED_VALUE: 9
  UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION: 3
                              DIVIDE_BY_ZERO: 2
                DANGLING_POINTER_DEREFERENCE: 2
rm -f  common/osdep.o common/base.o common/cpu.o common/tables.o encoder/api.o common/mc-8.o common/predict-8.o common/pixel-8.o common/macroblock-8.o common/frame-8.o common/dct-8.o common/cabac-8.o common/common-8.o common/rectangle-8.o common/set-8.o common/quant-8.o common/deblock-8.o common/vlc-8.o common/mvpred-8.o common/bitstream-8.o encoder/analyse-8.o encoder/me-8.o encoder/ratecontrol-8.o encoder/set-8.o encoder/macroblock-8.o encoder/cabac-8.o encoder/cavlc-8.o encoder/encoder-8.o encoder/lookahead-8.o common/threadpool-8.o common/x86/mc-c-8.o common/x86/predict-c-8.o common/opencl-8.o encoder/slicetype-cl-8.o common/mc-10.o common/predict-10.o common/pixel-10.o common/macroblock-10.o common/frame-10.o common/dct-10.o common/cabac-10.o common/common-10.o common/rectangle-10.o common/set-10.o common/quant-10.o common/deblock-10.o common/vlc-10.o common/mvpred-10.o common/bitstream-10.o encoder/analyse-10.o encoder/me-10.o encoder/ratecontrol-10.o encoder/set-10.o encoder/macroblock-10.o encoder/cabac-10.o encoder/cavlc-10.o encoder/encoder-10.o encoder/lookahead-10.o common/threadpool-10.o common/x86/mc-c-10.o common/x86/predict-c-10.o  common/x86/cpu-a.o common/x86/dct-64-8.o common/x86/trellis-64-8.o common/x86/bitstream-a-8.o common/x86/const-a-8.o common/x86/cabac-a-8.o common/x86/dct-a-8.o common/x86/deblock-a-8.o common/x86/mc-a-8.o common/x86/mc-a2-8.o common/x86/pixel-a-8.o common/x86/predict-a-8.o common/x86/quant-a-8.o common/x86/sad-a-8.o common/x86/dct-64-10.o common/x86/trellis-64-10.o common/x86/bitstream-a-10.o common/x86/const-a-10.o common/x86/cabac-a-10.o common/x86/dct-a-10.o common/x86/deblock-a-10.o common/x86/mc-a-10.o common/x86/mc-a2-10.o common/x86/pixel-a-10.o common/x86/predict-a-10.o common/x86/quant-a-10.o common/x86/sad16-a-10.o  x264.o autocomplete.o input/input.o input/timecode.o input/raw.o input/y4m.o output/raw.o output/matroska.o output/matroska_ebml.o output/flv.o output/flv_bytestream.o filters/filters.o filters/video/video.o filters/video/source.o filters/video/internal.o filters/video/resize.o filters/video/fix_vfr_pts.o filters/video/select_every.o filters/video/crop.o input/avs.o filters/video/cache-8.o filters/video/depth-8.o input/thread-8.o filters/video/cache-10.o filters/video/depth-10.o input/thread-10.o    common/oclobj.h .depend TAGS
rm -f  *.a *.lib *.exp *.pdb x264 x264_lookahead.clbin
rm -f checkasm8 checkasm10  tools/checkasm-a.o  tools/checkasm-8.o  tools/checkasm-10.o
rm -f example  example.o
rm -f common/osdep.gcda common/base.gcda common/cpu.gcda common/tables.gcda encoder/api.gcda common/mc-8.gcda common/predict-8.gcda common/pixel-8.gcda common/macroblock-8.gcda common/frame-8.gcda common/dct-8.gcda common/cabac-8.gcda common/common-8.gcda common/rectangle-8.gcda common/set-8.gcda common/quant-8.gcda common/deblock-8.gcda common/vlc-8.gcda common/mvpred-8.gcda common/bitstream-8.gcda encoder/analyse-8.gcda encoder/me-8.gcda encoder/ratecontrol-8.gcda encoder/set-8.gcda encoder/macroblock-8.gcda encoder/cabac-8.gcda encoder/cavlc-8.gcda encoder/encoder-8.gcda encoder/lookahead-8.gcda common/threadpool-8.gcda common/x86/mc-c-8.gcda common/x86/predict-c-8.gcda common/opencl-8.gcda encoder/slicetype-cl-8.gcda common/mc-10.gcda common/predict-10.gcda common/pixel-10.gcda common/macroblock-10.gcda common/frame-10.gcda common/dct-10.gcda common/cabac-10.gcda common/common-10.gcda common/rectangle-10.gcda common/set-10.gcda common/quant-10.gcda common/deblock-10.gcda common/vlc-10.gcda common/mvpred-10.gcda common/bitstream-10.gcda encoder/analyse-10.gcda encoder/me-10.gcda encoder/ratecontrol-10.gcda encoder/set-10.gcda encoder/macroblock-10.gcda encoder/cabac-10.gcda encoder/cavlc-10.gcda encoder/encoder-10.gcda encoder/lookahead-10.gcda common/threadpool-10.gcda common/x86/mc-c-10.gcda common/x86/predict-c-10.gcda x264.gcda autocomplete.gcda input/input.gcda input/timecode.gcda input/raw.gcda input/y4m.gcda output/raw.gcda output/matroska.gcda output/matroska_ebml.gcda output/flv.gcda output/flv_bytestream.gcda filters/filters.gcda filters/video/video.gcda filters/video/source.gcda filters/video/internal.gcda filters/video/resize.gcda filters/video/fix_vfr_pts.gcda filters/video/select_every.gcda filters/video/crop.gcda input/avs.gcda filters/video/cache-8.gcda filters/video/depth-8.gcda input/thread-8.gcda filters/video/cache-10.gcda filters/video/depth-10.gcda input/thread-10.gcda common/osdep.gcno common/base.gcno common/cpu.gcno common/tables.gcno encoder/api.gcno common/mc-8.gcno common/predict-8.gcno common/pixel-8.gcno common/macroblock-8.gcno common/frame-8.gcno common/dct-8.gcno common/cabac-8.gcno common/common-8.gcno common/rectangle-8.gcno common/set-8.gcno common/quant-8.gcno common/deblock-8.gcno common/vlc-8.gcno common/mvpred-8.gcno common/bitstream-8.gcno encoder/analyse-8.gcno encoder/me-8.gcno encoder/ratecontrol-8.gcno encoder/set-8.gcno encoder/macroblock-8.gcno encoder/cabac-8.gcno encoder/cavlc-8.gcno encoder/encoder-8.gcno encoder/lookahead-8.gcno common/threadpool-8.gcno common/x86/mc-c-8.gcno common/x86/predict-c-8.gcno common/opencl-8.gcno encoder/slicetype-cl-8.gcno common/mc-10.gcno common/predict-10.gcno common/pixel-10.gcno common/macroblock-10.gcno common/frame-10.gcno common/dct-10.gcno common/cabac-10.gcno common/common-10.gcno common/rectangle-10.gcno common/set-10.gcno common/quant-10.gcno common/deblock-10.gcno common/vlc-10.gcno common/mvpred-10.gcno common/bitstream-10.gcno encoder/analyse-10.gcno encoder/me-10.gcno encoder/ratecontrol-10.gcno encoder/set-10.gcno encoder/macroblock-10.gcno encoder/cabac-10.gcno encoder/cavlc-10.gcno encoder/encoder-10.gcno encoder/lookahead-10.gcno common/threadpool-10.gcno common/x86/mc-c-10.gcno common/x86/predict-c-10.gcno x264.gcno autocomplete.gcno input/input.gcno input/timecode.gcno input/raw.gcno input/y4m.gcno output/raw.gcno output/matroska.gcno output/matroska_ebml.gcno output/flv.gcno output/flv_bytestream.gcno filters/filters.gcno filters/video/video.gcno filters/video/source.gcno filters/video/internal.gcno filters/video/resize.gcno filters/video/fix_vfr_pts.gcno filters/video/select_every.gcno filters/video/crop.gcno input/avs.gcno filters/video/cache-8.gcno filters/video/depth-8.gcno input/thread-8.gcno filters/video/cache-10.gcno filters/video/depth-10.gcno input/thread-10.gcno *.dyn pgopti.dpi pgopti.dpi.lock *.pgd *.pgc
cat common/opencl/x264-cl.h common/opencl/motionsearch.cl common/opencl/subpel.cl common/opencl/intra.cl common/opencl/weightp.cl common/opencl/bidir.cl common/opencl/downscale.cl | ./tools/cltostr.sh common/oclobj.h
dependency file generation...
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c x264.c -o x264.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c autocomplete.c -o autocomplete.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/input.c -o input/input.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/timecode.c -o input/timecode.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/raw.c -o input/raw.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/y4m.c -o input/y4m.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/raw.c -o output/raw.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/matroska.c -o output/matroska.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/matroska_ebml.c -o output/matroska_ebml.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/flv.c -o output/flv.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c output/flv_bytestream.c -o output/flv_bytestream.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/filters.c -o filters/filters.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/video.c -o filters/video/video.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/source.c -o filters/video/source.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/internal.c -o filters/video/internal.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/resize.c -o filters/video/resize.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/fix_vfr_pts.c -o filters/video/fix_vfr_pts.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/select_every.c -o filters/video/select_every.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/crop.c -o filters/video/crop.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/avs.c -o input/avs.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/cache.c -o filters/video/cache-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/depth.c -o filters/video/depth-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/thread.c -o input/thread-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/cache.c -o filters/video/cache-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c filters/video/depth.c -o filters/video/depth-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c input/thread.c -o input/thread-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/osdep.c -o common/osdep.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/base.c -o common/base.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/cpu.c -o common/cpu.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/tables.c -o common/tables.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/api.c -o encoder/api.o
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mc.c -o common/mc-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/predict.c -o common/predict-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/pixel.c -o common/pixel-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/macroblock.c -o common/macroblock-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/frame.c -o common/frame-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/dct.c -o common/dct-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/cabac.c -o common/cabac-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/common.c -o common/common-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/rectangle.c -o common/rectangle-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/set.c -o common/set-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/quant.c -o common/quant-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/deblock.c -o common/deblock-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/vlc.c -o common/vlc-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mvpred.c -o common/mvpred-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/bitstream.c -o common/bitstream-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/analyse.c -o encoder/analyse-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/me.c -o encoder/me-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/ratecontrol.c -o encoder/ratecontrol-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/set.c -o encoder/set-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/macroblock.c -o encoder/macroblock-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cabac.c -o encoder/cabac-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cavlc.c -o encoder/cavlc-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/encoder.c -o encoder/encoder-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/lookahead.c -o encoder/lookahead-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/threadpool.c -o common/threadpool-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/mc-c.c -o common/x86/mc-c-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/predict-c.c -o common/x86/predict-c-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/opencl.c -o common/opencl-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/slicetype-cl.c -o encoder/slicetype-cl-8.o -DHIGH_BIT_DEPTH=0 -DBIT_DEPTH=8
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mc.c -o common/mc-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/predict.c -o common/predict-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/pixel.c -o common/pixel-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/macroblock.c -o common/macroblock-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/frame.c -o common/frame-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/dct.c -o common/dct-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/cabac.c -o common/cabac-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/common.c -o common/common-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/rectangle.c -o common/rectangle-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/set.c -o common/set-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/quant.c -o common/quant-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/deblock.c -o common/deblock-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/vlc.c -o common/vlc-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/mvpred.c -o common/mvpred-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/bitstream.c -o common/bitstream-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/analyse.c -o encoder/analyse-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/me.c -o encoder/me-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/ratecontrol.c -o encoder/ratecontrol-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/set.c -o encoder/set-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/macroblock.c -o encoder/macroblock-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cabac.c -o encoder/cabac-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/cavlc.c -o encoder/cavlc-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/encoder.c -o encoder/encoder-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c encoder/lookahead.c -o encoder/lookahead-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/threadpool.c -o common/threadpool-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/mc-c.c -o common/x86/mc-c-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
gcc -Wno-maybe-uninitialized -Wshadow -O3 -ffast-math -m64  -Wall -I. -I. -std=gnu99 -D_GNU_SOURCE -fomit-frame-pointer -fno-tree-vectorize -c common/x86/predict-c.c -o common/x86/predict-c-10.o -DHIGH_BIT_DEPTH=1 -DBIT_DEPTH=10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/cpu-a.o common/x86/cpu-a.asm
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-64-8.o common/x86/dct-64.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/trellis-64-8.o common/x86/trellis-64.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/bitstream-a-8.o common/x86/bitstream-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/const-a-8.o common/x86/const-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/cabac-a-8.o common/x86/cabac-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-a-8.o common/x86/dct-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/deblock-a-8.o common/x86/deblock-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a-8.o common/x86/mc-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a2-8.o common/x86/mc-a2.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/pixel-a-8.o common/x86/pixel-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/predict-a-8.o common/x86/predict-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/quant-a-8.o common/x86/quant-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/sad-a-8.o common/x86/sad-a.asm -DBIT_DEPTH=8 -Dprivate_prefix=x264_8
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-64-10.o common/x86/dct-64.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/trellis-64-10.o common/x86/trellis-64.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/bitstream-a-10.o common/x86/bitstream-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/const-a-10.o common/x86/const-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/cabac-a-10.o common/x86/cabac-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/dct-a-10.o common/x86/dct-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/deblock-a-10.o common/x86/deblock-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a-10.o common/x86/mc-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/mc-a2-10.o common/x86/mc-a2.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/pixel-a-10.o common/x86/pixel-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/predict-a-10.o common/x86/predict-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/quant-a-10.o common/x86/quant-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
nasm -I. -I. -DARCH_X86_64=1 -I./common/x86/ -f elf64 -DSTACK_ALIGNMENT=64 -o common/x86/sad16-a-10.o common/x86/sad16-a.asm -DBIT_DEPTH=10 -Dprivate_prefix=x264_10
rm -f libx264.a
gcc-ar rc libx264.a  common/osdep.o common/base.o common/cpu.o common/tables.o encoder/api.o common/mc-8.o common/predict-8.o common/pixel-8.o common/macroblock-8.o common/frame-8.o common/dct-8.o common/cabac-8.o common/common-8.o common/rectangle-8.o common/set-8.o common/quant-8.o common/deblock-8.o common/vlc-8.o common/mvpred-8.o common/bitstream-8.o encoder/analyse-8.o encoder/me-8.o encoder/ratecontrol-8.o encoder/set-8.o encoder/macroblock-8.o encoder/cabac-8.o encoder/cavlc-8.o encoder/encoder-8.o encoder/lookahead-8.o common/threadpool-8.o common/x86/mc-c-8.o common/x86/predict-c-8.o common/opencl-8.o encoder/slicetype-cl-8.o common/mc-10.o common/predict-10.o common/pixel-10.o common/macroblock-10.o common/frame-10.o common/dct-10.o common/cabac-10.o common/common-10.o common/rectangle-10.o common/set-10.o common/quant-10.o common/deblock-10.o common/vlc-10.o common/mvpred-10.o common/bitstream-10.o encoder/analyse-10.o encoder/me-10.o encoder/ratecontrol-10.o encoder/set-10.o encoder/macroblock-10.o encoder/cabac-10.o encoder/cavlc-10.o encoder/encoder-10.o encoder/lookahead-10.o common/threadpool-10.o common/x86/mc-c-10.o common/x86/predict-c-10.o  common/x86/cpu-a.o common/x86/dct-64-8.o common/x86/trellis-64-8.o common/x86/bitstream-a-8.o common/x86/const-a-8.o common/x86/cabac-a-8.o common/x86/dct-a-8.o common/x86/deblock-a-8.o common/x86/mc-a-8.o common/x86/mc-a2-8.o common/x86/pixel-a-8.o common/x86/predict-a-8.o common/x86/quant-a-8.o common/x86/sad-a-8.o common/x86/dct-64-10.o common/x86/trellis-64-10.o common/x86/bitstream-a-10.o common/x86/const-a-10.o common/x86/cabac-a-10.o common/x86/dct-a-10.o common/x86/deblock-a-10.o common/x86/mc-a-10.o common/x86/mc-a2-10.o common/x86/pixel-a-10.o common/x86/predict-a-10.o common/x86/quant-a-10.o common/x86/sad16-a-10.o
gcc-ranlib libx264.a
gcc -o x264  x264.o autocomplete.o input/input.o input/timecode.o input/raw.o input/y4m.o output/raw.o output/matroska.o output/matroska_ebml.o output/flv.o output/flv_bytestream.o filters/filters.o filters/video/video.o filters/video/source.o filters/video/internal.o filters/video/resize.o filters/video/fix_vfr_pts.o filters/video/select_every.o filters/video/crop.o input/avs.o filters/video/cache-8.o filters/video/depth-8.o input/thread-8.o filters/video/cache-10.o filters/video/depth-10.o input/thread-10.o libx264.a -ldl  -m64  -lm -lpthread -ldl
Starting analysis (Infer version v0.9.3)

legend:
  "F" analyzing a file
  "." analyzing a procedure

SEARCH STORE SIZE 2449
SIZE OF ERRORS: 0

Analyzed 57 files

Found 298 issues

/usr/include/x86_64-linux-gnu/bits/string2.h:1215: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1215, column 14
  1213.       {
  1214.         char *__cp = __retval;
  1215. >       while (1)
  1216.   	{
  1217.   	  if (*__cp == '\0')
  1218.   

/usr/include/x86_64-linux-gnu/bits/string2.h:1243: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1243, column 14
  1241.       {
  1242.         char *__cp = __retval;
  1243. >       while (1)
  1244.   	{
  1245.   	  if (*__cp == '\0')
  1246.   

autocomplete.c:292: warning: PRECONDITION_NOT_MET
  in call to strlen() at line 292, column 19
  290.   int x264_cli_autocomplete( const char *prev, const char *cur )
  291.   {
  292. >     int cur_len = strlen( cur );
  293.       if( 0 );
  294.       OPT( "--alternative-transfer" )
  295.   

common/base.c:186: error: ARRAY_OUT_OF_BOUNDS_L1
  array buf last assigned on line 174 could be accessed with index -1 out of bounds at line 186, column 9
  184.       }
  185.   
  186. >     if( buf[i_size-1] != '\n' )
  187.           buf[i_size++] = '\n';
  188.       buf[i_size] = '\0';
  189.   

common/base.c:799: warning: UNINITIALIZED_VALUE
  value coef was not initialized after declaration and is used at line 799, column 44
  797.       do {
  798.           int coef;
  799. >         if( !sscanf( str, "%d", &coef ) || coef < 1 || coef > 255 )
  800.               return -1;
  801.           cqm[i++] = coef;
  802.   

common/base.c:802: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((44==0)!=0) is always false at line 802, column 35
  800.               return -1;
  801.           cqm[i++] = coef;
  802. >     } while( i < length && (str = strchr( str, ',' )) && str++ );
  803.       return (i == length) ? 0 : -1;
  804.   }
  805.   

common/bitstream.c:35: error: ARRAY_OUT_OF_BOUNDS_L1
  array dst last assigned on line 32 could be accessed with index -2 out of bounds at line 35, column 32
  33.       while( src < end )
  34.       {
  35. >         if( src[0] <= 0x03 && !dst[-2] && !dst[-1] )
  36.               *dst++ = 0x03;
  37.           *dst++ = *src++;
  38.   

common/cabac.c:89: error: ARRAY_OUT_OF_BOUNDS_L1
  array cb->p could be accessed with index -1 out of bounds at line 89, column 13
  87.               // this can't carry beyond the one byte, because any 0xff bytes
  88.               // are in bytes_outstanding and thus not written yet.
  89. >             cb->p[-1] += carry;
  90.               while( bytes_outstanding > 0 )
  91.               {
  92.   

common/cabac.c:176: warning: PRECONDITION_NOT_MET
  in call to cabac_putbyte() at line 176, column 5
  174.       cb->i_low |= (0x35a4e4f5 >> (h->i_frame & 31) & 1) << 10;
  175.       cb->i_queue = 0;
  176. >     cabac_putbyte( cb );
  177.   
  178.       while( cb->i_bytes_outstanding > 0 )
  179.   

common/frame.c:852: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 852, column 5
  850.       slist->i_max_size = max_size;
  851.       slist->i_size = 0;
  852. >     CHECKED_MALLOCZERO( slist->list, (max_size+1) * sizeof(x264_frame_t*) );
  853.       if( x264_pthread_mutex_init( &slist->mutex, NULL ) ||
  854.           x264_pthread_cond_init( &slist->cv_fill, NULL ) ||
  855.   

common/macroblock.c:44: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 44, column 5
  42.       int mvy   = x264_clip3( h->mb.cache.mv[0][i8][1], h->mb.mv_min[1], h->mb.mv_max[1] ) + 4*4*y;
  43.   
  44. >     MC_LUMA( 0, 0 );
  45.   
  46.       if( CHROMA444 )
  47.   

common/macroblock.c:83: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 83, column 5
  81.       int mvy   = x264_clip3( h->mb.cache.mv[1][i8][1], h->mb.mv_min[1], h->mb.mv_max[1] ) + 4*4*y;
  82.   
  83. >     MC_LUMA( 1, 0 );
  84.   
  85.       if( CHROMA444 )
  86.   

common/macroblock.c:260: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 260, column 5
  258.       PREALLOC_INIT
  259.   
  260. >     PREALLOC( h->mb.qp, i_mb_count * sizeof(int8_t) );
  261.       PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262.       PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263.   

common/macroblock.c:261: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 261, column 5
  259.   
  260.       PREALLOC( h->mb.qp, i_mb_count * sizeof(int8_t) );
  261. >     PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262.       PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263.       PREALLOC( h->mb.slice_table, i_mb_count * sizeof(uint32_t) );
  264.   

common/macroblock.c:262: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 262, column 5
  260.       PREALLOC( h->mb.qp, i_mb_count * sizeof(int8_t) );
  261.       PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262. >     PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263.       PREALLOC( h->mb.slice_table, i_mb_count * sizeof(uint32_t) );
  264.   
  265.   

common/macroblock.c:263: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 263, column 5
  261.       PREALLOC( h->mb.cbp, i_mb_count * sizeof(int16_t) );
  262.       PREALLOC( h->mb.mb_transform_size, i_mb_count * sizeof(int8_t) );
  263. >     PREALLOC( h->mb.slice_table, i_mb_count * sizeof(uint32_t) );
  264.   
  265.       /* 0 -> 3 top(4), 4 -> 6 : left(3) */
  266.   

common/macroblock.c:266: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 266, column 5
  264.   
  265.       /* 0 -> 3 top(4), 4 -> 6 : left(3) */
  266. >     PREALLOC( h->mb.intra4x4_pred_mode, i_mb_count * 8 * sizeof(int8_t) );
  267.   
  268.       /* all coeffs */
  269.   

common/macroblock.c:269: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 269, column 5
  267.   
  268.       /* all coeffs */
  269. >     PREALLOC( h->mb.non_zero_count, i_mb_count * 48 * sizeof(uint8_t) );
  270.   
  271.       if( h->param.b_cabac )
  272.   

common/macroblock.c:273: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 273, column 9
  271.       if( h->param.b_cabac )
  272.       {
  273. >         PREALLOC( h->mb.skipbp, i_mb_count * sizeof(int8_t) );
  274.           PREALLOC( h->mb.chroma_pred_mode, i_mb_count * sizeof(int8_t) );
  275.           PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.   

common/macroblock.c:274: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 274, column 9
  272.       {
  273.           PREALLOC( h->mb.skipbp, i_mb_count * sizeof(int8_t) );
  274. >         PREALLOC( h->mb.chroma_pred_mode, i_mb_count * sizeof(int8_t) );
  275.           PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.           if( h->param.i_bframe )
  277.   

common/macroblock.c:275: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 275, column 9
  273.           PREALLOC( h->mb.skipbp, i_mb_count * sizeof(int8_t) );
  274.           PREALLOC( h->mb.chroma_pred_mode, i_mb_count * sizeof(int8_t) );
  275. >         PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.           if( h->param.i_bframe )
  277.               PREALLOC( h->mb.mvd[1], i_mb_count * sizeof( **h->mb.mvd ) );
  278.   

common/macroblock.c:277: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 277, column 13
  275.           PREALLOC( h->mb.mvd[0], i_mb_count * sizeof( **h->mb.mvd ) );
  276.           if( h->param.i_bframe )
  277. >             PREALLOC( h->mb.mvd[1], i_mb_count * sizeof( **h->mb.mvd ) );
  278.       }
  279.   
  280.   

common/macroblock.c:394: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 394, column 9
  392.       scratch_size = X264_MAX( scratch_size, buf_mbtree );
  393.       if( scratch_size )
  394. >         CHECKED_MALLOC( h->scratch_buffer, scratch_size );
  395.       else
  396.           h->scratch_buffer = NULL;
  397.   

common/macroblock.c:437: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fref[0] of size 2 could be accessed with an index out of bounds at line 437, column 34
  435.       h->fdec->i_ref[1] = h->i_ref[1];
  436.       for( int i = 0; i < h->i_ref[0]; i++ )
  437. >         h->fdec->ref_poc[0][i] = h->fref[0][i]->i_poc;
  438.       if( h->sh.i_type == SLICE_TYPE_B )
  439.       {
  440.   

common/macroblock.c:437: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fdec->ref_poc[0] of size 16 could be accessed with an index out of bounds at line 437, column 9
  435.       h->fdec->i_ref[1] = h->i_ref[1];
  436.       for( int i = 0; i < h->i_ref[0]; i++ )
  437. >         h->fdec->ref_poc[0][i] = h->fref[0][i]->i_poc;
  438.       if( h->sh.i_type == SLICE_TYPE_B )
  439.       {
  440.   

common/macroblock.c:565: error: ARRAY_OUT_OF_BOUNDS_L1
  array dst could be accessed with index -128 out of bounds at line 565, column 9
  563.       // input pointers are offset by 4 rows because that's faster (smaller instruction size on x86)
  564.       for( int i = -4; i < 4; i++ )
  565. >         dst[i*FDEC_STRIDE] = src[i*FDEC_STRIDE];
  566.   }
  567.   
  568.   

common/macroblock.c:565: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -128 out of bounds at line 565, column 30
  563.       // input pointers are offset by 4 rows because that's faster (smaller instruction size on x86)
  564.       for( int i = -4; i < 4; i++ )
  565. >         dst[i*FDEC_STRIDE] = src[i*FDEC_STRIDE];
  566.   }
  567.   
  568.   

common/mc.c:174: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>9)!=0) is always true at line 174, column 34
  172.                            intptr_t stride, int width, int height, int16_t *buf )
  173.   {
  174. >     const int pad = (BIT_DEPTH > 9) ? (-10 * PIXEL_MAX) : 0;
  175.       for( int y = 0; y < height; y++ )
  176.       {
  177.   

common/mc.c:179: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -2 out of bounds at line 179, column 21
  177.           for( int x = -2; x < width+3; x++ )
  178.           {
  179. >             int v = TAPFILTER(src,stride);
  180.               dstv[x] = x264_clip_pixel( (v + 16) >> 5 );
  181.               /* transform v for storage in a 16-bit integer */
  182.   

common/mc.c:180: warning: PRECONDITION_NOT_MET
  in call to x264_clip_pixel() at line 180, column 54
  178.           {
  179.               int v = TAPFILTER(src,stride);
  180. >             dstv[x] = x264_clip_pixel( (v + 16) >> 5 );
  181.               /* transform v for storage in a 16-bit integer */
  182.               buf[x+2] = v + pad;
  183.   

common/mc.c:426: error: ARRAY_OUT_OF_BOUNDS_L1
  array sum could be accessed with an index out of bounds at line 426, column 22
  424.       for( int x = 0; x < stride-4; x++ )
  425.       {
  426. >         sum[x] = v + sum[x-stride];
  427.           v += pix[x+4] - pix[x];
  428.       }
  429.   

common/mc.c:436: error: ARRAY_OUT_OF_BOUNDS_L1
  array sum could be accessed with an index out of bounds at line 436, column 22
  434.       for( int x = 0; x < stride-8; x++ )
  435.       {
  436. >         sum[x] = v + sum[x-stride];
  437.           v += pix[x+8] - pix[x];
  438.       }
  439.   

common/opencl.c:58: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 58, column 5
  56.   #undef fail
  57.   #define fail fail0
  58. >     CHECKED_MALLOCZERO( ocl, sizeof(x264_opencl_function_t) );
  59.   #undef fail
  60.   #define fail fail1
  61.   

common/opencl.c:125: warning: PRECONDITION_NOT_MET
  in call to fopen() at line 125, column 16
  123.   {
  124.       /* try to load cached program binary */
  125. >     FILE *fp = x264_fopen( h->param.psz_clbin_file, "rb" );
  126.       if( !fp )
  127.           return NULL;
  128.   

common/opencl.c:191: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 191, column 5
  189.       }
  190.   
  191. >     CHECKED_MALLOC( binary, size );
  192.       status = ocl->clGetProgramInfo( program, CL_PROGRAM_BINARIES, sizeof(uint8_t *), &binary, NULL );
  193.       if( status != CL_SUCCESS )
  194.   

common/opencl.c:559: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 559, column 5
  557.   
  558.   #define RELEASE( a, f ) do { if( a ) { ocl->f( a ); a = NULL; } } while( 0 )
  559. >     RELEASE( h->opencl.downscale_hpel_kernel, clReleaseKernel );
  560.       RELEASE( h->opencl.downscale_kernel1, clReleaseKernel );
  561.       RELEASE( h->opencl.downscale_kernel2, clReleaseKernel );
  562.   

common/opencl.c:560: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 560, column 5
  558.   #define RELEASE( a, f ) do { if( a ) { ocl->f( a ); a = NULL; } } while( 0 )
  559.       RELEASE( h->opencl.downscale_hpel_kernel, clReleaseKernel );
  560. >     RELEASE( h->opencl.downscale_kernel1, clReleaseKernel );
  561.       RELEASE( h->opencl.downscale_kernel2, clReleaseKernel );
  562.       RELEASE( h->opencl.weightp_hpel_kernel, clReleaseKernel );
  563.   

common/opencl.c:561: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 561, column 5
  559.       RELEASE( h->opencl.downscale_hpel_kernel, clReleaseKernel );
  560.       RELEASE( h->opencl.downscale_kernel1, clReleaseKernel );
  561. >     RELEASE( h->opencl.downscale_kernel2, clReleaseKernel );
  562.       RELEASE( h->opencl.weightp_hpel_kernel, clReleaseKernel );
  563.       RELEASE( h->opencl.weightp_scaled_images_kernel, clReleaseKernel );
  564.   

common/opencl.c:626: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 626, column 9
  624.   #define RELEASEBUF(mem) do { if( mem ) { ocl->clReleaseMemObject( mem ); mem = NULL; } } while( 0 )
  625.       for( int j = 0; j < NUM_IMAGE_SCALES; j++ )
  626. >         RELEASEBUF( frame->opencl.scaled_image2Ds[j] );
  627.       RELEASEBUF( frame->opencl.luma_hpel );
  628.       RELEASEBUF( frame->opencl.inv_qscale_factor );
  629.   

common/osdep.h:413: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 413, column 17
  411.       x264_struct_stat file_stat;
  412.       if( x264_stat( filename, &file_stat ) )
  413. >         return !x264_is_pipe( filename );
  414.       return S_ISREG( file_stat.st_mode );
  415.   }
  416.   

common/pixel.c:325: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 325, column 1
  323.       return sum;\
  324.   }
  325. > PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   

common/pixel.c:326: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 326, column 1
  324.   }
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326. > PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   

common/pixel.c:326: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 326, column 1
  324.   }
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326. > PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   

common/pixel.c:327: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 327, column 1
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327. > PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   

common/pixel.c:327: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 327, column 1
  325.   PIXEL_SATD_C( 16, 16, x264_pixel_satd_8x4 )
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327. > PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   

common/pixel.c:328: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 328, column 1
  326.   PIXEL_SATD_C( 16, 8,  x264_pixel_satd_8x4 )
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328. > PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   

common/pixel.c:329: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 329, column 1
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329. > PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   

common/pixel.c:329: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((4==16)!=0) is always false at line 329, column 1
  327.   PIXEL_SATD_C( 8,  16, x264_pixel_satd_8x4 )
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329. > PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330.   PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   

common/pixel.c:330: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((4==16)!=0) is always false at line 330, column 1
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330. > PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   static NOINLINE int sa8d_8x8( pixel *pix1, intptr_t i_pix1, pixel *pix2, intptr_t i_pix2 )
  333.   

common/pixel.c:330: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 330, column 1
  328.   PIXEL_SATD_C( 8,  8,  x264_pixel_satd_8x4 )
  329.   PIXEL_SATD_C( 4,  16, x264_pixel_satd_4x4 )
  330. > PIXEL_SATD_C( 4,  8,  x264_pixel_satd_4x4 )
  331.   
  332.   static NOINLINE int sa8d_8x8( pixel *pix1, intptr_t i_pix1, pixel *pix2, intptr_t i_pix2 )
  333.   

common/pixel.c:430: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 430, column 1
  428.       return ((sum>>34)<<32) + ((uint32_t)sum>>1);\
  429.   }
  430. > HADAMARD_AC( 16, 16 )
  431.   HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433.   

common/pixel.c:431: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 431, column 1
  429.   }
  430.   HADAMARD_AC( 16, 16 )
  431. > HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   

common/pixel.c:431: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 431, column 1
  429.   }
  430.   HADAMARD_AC( 16, 16 )
  431. > HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   

common/pixel.c:432: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((16==16)!=0) is always true at line 432, column 1
  430.   HADAMARD_AC( 16, 16 )
  431.   HADAMARD_AC( 16, 8 )
  432. > HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   
  435.   

common/pixel.c:432: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 432, column 1
  430.   HADAMARD_AC( 16, 16 )
  431.   HADAMARD_AC( 16, 8 )
  432. > HADAMARD_AC( 8, 16 )
  433.   HADAMARD_AC( 8, 8 )
  434.   
  435.   

common/pixel.c:433: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((8==16)!=0) is always false at line 433, column 1
  431.   HADAMARD_AC( 16, 8 )
  432.   HADAMARD_AC( 8, 16 )
  433. > HADAMARD_AC( 8, 8 )
  434.   
  435.   
  436.   

common/pixel.c:528: warning: PRECONDITION_NOT_MET
  in call to x264_10_predict_8x8_v_c() at line 528, column 1
  526.   }
  527.   
  528. > INTRA_MBCMP_8x8( sad,, _c )
  529.   INTRA_MBCMP_8x8(sa8d,, _c )
  530.   #if HIGH_BIT_DEPTH && HAVE_MMX
  531.   

common/pixel.c:529: warning: PRECONDITION_NOT_MET
  in call to x264_10_predict_8x8_v_c() at line 529, column 1
  527.   
  528.   INTRA_MBCMP_8x8( sad,, _c )
  529. > INTRA_MBCMP_8x8(sa8d,, _c )
  530.   #if HIGH_BIT_DEPTH && HAVE_MMX
  531.   #define x264_predict_8x8_v_sse2 x264_predict_8x8_v_sse
  532.   

common/pixel.c:532: warning: PRECONDITION_NOT_MET
  in call to x264_10_predict_8x8_v_c() at line 532, column 1
  530.   #if HIGH_BIT_DEPTH && HAVE_MMX
  531.   #define x264_predict_8x8_v_sse2 x264_predict_8x8_v_sse
  532. > INTRA_MBCMP_8x8( sad, _mmx2,  _c )
  533.   INTRA_MBCMP_8x8(sa8d, _sse2,  _sse2 )
  534.   #endif
  535.   

common/pixel.c:703: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 703, column 13
  701.           for( ; z <= y; z++ )
  702.           {
  703. >             XCHG( void*, sum0, sum1 );
  704.               for( int x = 0; x < width; x+=2 )
  705.                   pf->ssim_4x4x2_core( &pix1[4*(x+z*stride1)], stride1, &pix2[4*(x+z*stride2)], stride2, &sum0[x] );
  706.   

common/predict.c:70: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 70, column 15
  68.       for( int i = 0; i < 16; i++ )
  69.       {
  70. >         dc += src[-1 + i * FDEC_STRIDE];
  71.           dc += src[i - FDEC_STRIDE];
  72.       }
  73.   

common/predict.c:71: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 71, column 15
  69.       {
  70.           dc += src[-1 + i * FDEC_STRIDE];
  71. >         dc += src[i - FDEC_STRIDE];
  72.       }
  73.       pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 16 ) >> 5 );
  74.   

common/predict.c:82: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 82, column 15
  80.   
  81.       for( int i = 0; i < 16; i++ )
  82. >         dc += src[-1 + i * FDEC_STRIDE];
  83.       pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 8 ) >> 4 );
  84.   
  85.   

common/predict.c:92: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 92, column 15
  90.   
  91.       for( int i = 0; i < 16; i++ )
  92. >         dc += src[i - FDEC_STRIDE];
  93.       pixel4 dcsplat = PIXEL_SPLAT_X4( ( dc + 8 ) >> 4 );
  94.   
  95.   

common/predict.c:105: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 105, column 26
  103.       for( int i = 0; i < 16; i++ )
  104.       {
  105. >         const pixel4 v = PIXEL_SPLAT_X4( src[-1] );
  106.           MPIXEL_X4( src+ 0 ) = v;
  107.           MPIXEL_X4( src+ 4 ) = v;
  108.   

common/predict.c:115: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 115, column 17
  113.   void x264_predict_16x16_v_c( pixel *src )
  114.   {
  115. >     pixel4 v0 = MPIXEL_X4( &src[ 0-FDEC_STRIDE] );
  116.       pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117.       pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118.   

common/predict.c:116: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 116, column 17
  114.   {
  115.       pixel4 v0 = MPIXEL_X4( &src[ 0-FDEC_STRIDE] );
  116. >     pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117.       pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118.       pixel4 v3 = MPIXEL_X4( &src[12-FDEC_STRIDE] );
  119.   

common/predict.c:117: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -24 out of bounds at line 117, column 17
  115.       pixel4 v0 = MPIXEL_X4( &src[ 0-FDEC_STRIDE] );
  116.       pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117. >     pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118.       pixel4 v3 = MPIXEL_X4( &src[12-FDEC_STRIDE] );
  119.   
  120.   

common/predict.c:118: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -20 out of bounds at line 118, column 17
  116.       pixel4 v1 = MPIXEL_X4( &src[ 4-FDEC_STRIDE] );
  117.       pixel4 v2 = MPIXEL_X4( &src[ 8-FDEC_STRIDE] );
  118. >     pixel4 v3 = MPIXEL_X4( &src[12-FDEC_STRIDE] );
  119.   
  120.       for( int i = 0; i < 16; i++ )
  121.   

common/predict.c:136: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -24 out of bounds at line 136, column 53
  134.       for( int i = 0; i <= 7; i++ )
  135.       {
  136. >         H += ( i + 1 ) * ( src[ 8 + i - FDEC_STRIDE ] - src[6 -i -FDEC_STRIDE] );
  137.           V += ( i + 1 ) * ( src[-1 + (8+i)*FDEC_STRIDE] - src[-1 + (6-i)*FDEC_STRIDE] );
  138.       }
  139.   

common/predict.c:179: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 179, column 16
  177.       for( int y = 0; y < 4; y++ )
  178.       {
  179. >         dc0 += src[y * FDEC_STRIDE     - 1];
  180.           dc1 += src[(y+4) * FDEC_STRIDE - 1];
  181.       }
  182.   

common/predict.c:205: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 205, column 16
  203.       for( int x = 0; x < 4; x++ )
  204.       {
  205. >         dc0 += src[x     - FDEC_STRIDE];
  206.           dc1 += src[x + 4 - FDEC_STRIDE];
  207.       }
  208.   

common/predict.c:206: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 206, column 16
  204.       {
  205.           dc0 += src[x     - FDEC_STRIDE];
  206. >         dc1 += src[x + 4 - FDEC_STRIDE];
  207.       }
  208.       pixel4 dc0splat = PIXEL_SPLAT_X4( ( dc0 + 2 ) >> 2 );
  209.   

common/predict.c:229: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 229, column 15
  227.       for( int i = 0; i < 4; i++ )
  228.       {
  229. >         s0 += src[i - FDEC_STRIDE];
  230.           s1 += src[i + 4 - FDEC_STRIDE];
  231.           s2 += src[-1 + i * FDEC_STRIDE];
  232.   

common/predict.c:230: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 230, column 15
  228.       {
  229.           s0 += src[i - FDEC_STRIDE];
  230. >         s1 += src[i + 4 - FDEC_STRIDE];
  231.           s2 += src[-1 + i * FDEC_STRIDE];
  232.           s3 += src[-1 + (i+4)*FDEC_STRIDE];
  233.   

common/predict.c:231: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 231, column 15
  229.           s0 += src[i - FDEC_STRIDE];
  230.           s1 += src[i + 4 - FDEC_STRIDE];
  231. >         s2 += src[-1 + i * FDEC_STRIDE];
  232.           s3 += src[-1 + (i+4)*FDEC_STRIDE];
  233.       }
  234.   

common/predict.c:261: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 261, column 20
  259.       for( int i = 0; i < 8; i++ )
  260.       {
  261. >         pixel4 v = PIXEL_SPLAT_X4( src[-1] );
  262.           MPIXEL_X4( src+0 ) = v;
  263.           MPIXEL_X4( src+4 ) = v;
  264.   

common/predict.c:285: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 285, column 49
  283.       for( int i = 0; i < 4; i++ )
  284.       {
  285. >         H += ( i + 1 ) * ( src[4+i - FDEC_STRIDE] - src[2 - i -FDEC_STRIDE] );
  286.           V += ( i + 1 ) * ( src[-1 +(i+4)*FDEC_STRIDE] - src[-1+(2-i)*FDEC_STRIDE] );
  287.       }
  288.   

common/predict.c:327: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 327, column 19
  325.   
  326.           for( int y = 0; y < 4; y++ )
  327. >             dc += src[y*FDEC_STRIDE - 1];
  328.   
  329.           pixel4 dcsplat = PIXEL_SPLAT_X4( (dc + 2) >> 2 );
  330.   

common/predict.c:345: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 345, column 16
  343.       for( int  x = 0; x < 4; x++ )
  344.       {
  345. >         dc0 += src[x     - FDEC_STRIDE];
  346.           dc1 += src[x + 4 - FDEC_STRIDE];
  347.       }
  348.   

common/predict.c:346: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 346, column 16
  344.       {
  345.           dc0 += src[x     - FDEC_STRIDE];
  346. >         dc1 += src[x + 4 - FDEC_STRIDE];
  347.       }
  348.       pixel4 dc0splat = PIXEL_SPLAT_X4( ( dc0 + 2 ) >> 2 );
  349.   

common/predict.c:371: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 371, column 15
  369.       for( int i = 0; i < 4; i++ )
  370.       {
  371. >         s0 += src[i+0 - FDEC_STRIDE];
  372.           s1 += src[i+4 - FDEC_STRIDE];
  373.           s2 += src[-1 + (i+0)  * FDEC_STRIDE];
  374.   

common/predict.c:372: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 372, column 15
  370.       {
  371.           s0 += src[i+0 - FDEC_STRIDE];
  372. >         s1 += src[i+4 - FDEC_STRIDE];
  373.           s2 += src[-1 + (i+0)  * FDEC_STRIDE];
  374.           s3 += src[-1 + (i+4)  * FDEC_STRIDE];
  375.   

common/predict.c:373: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 373, column 15
  371.           s0 += src[i+0 - FDEC_STRIDE];
  372.           s1 += src[i+4 - FDEC_STRIDE];
  373. >         s2 += src[-1 + (i+0)  * FDEC_STRIDE];
  374.           s3 += src[-1 + (i+4)  * FDEC_STRIDE];
  375.           s4 += src[-1 + (i+8)  * FDEC_STRIDE];
  376.   

common/predict.c:422: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 422, column 20
  420.       for( int i = 0; i < 16; i++ )
  421.       {
  422. >         pixel4 v = PIXEL_SPLAT_X4( src[-1] );
  423.           MPIXEL_X4( src+0 ) = v;
  424.           MPIXEL_X4( src+4 ) = v;
  425.   

common/predict.c:446: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 446, column 51
  444.   
  445.       for( int i = 0; i < 4; i++ )
  446. >         H += ( i + 1 ) * ( src[4 + i - FDEC_STRIDE] - src[2 - i - FDEC_STRIDE] );
  447.       for( int i = 0; i < 8; i++ )
  448.           V += ( i + 1 ) * ( src[-1 + (i+8)*FDEC_STRIDE] - src[-1 + (6-i)*FDEC_STRIDE] );
  449.   

common/predict.c:484: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 484, column 17
  482.   static void predict_4x4_dc_left_c( pixel *src )
  483.   {
  484. >     pixel4 dc = PIXEL_SPLAT_X4( (SRC(-1,0) + SRC(-1,1) + SRC(-1,2) + SRC(-1,3) + 2) >> 2 );
  485.       PREDICT_4x4_DC( dc );
  486.   }
  487.   

common/predict.c:489: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 489, column 17
  487.   static void predict_4x4_dc_top_c( pixel *src )
  488.   {
  489. >     pixel4 dc = PIXEL_SPLAT_X4( (SRC(0,-1) + SRC(1,-1) + SRC(2,-1) + SRC(3,-1) + 2) >> 2 );
  490.       PREDICT_4x4_DC( dc );
  491.   }
  492.   

common/predict.c:494: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 494, column 17
  492.   void x264_predict_4x4_dc_c( pixel *src )
  493.   {
  494. >     pixel4 dc = PIXEL_SPLAT_X4( (SRC(-1,0) + SRC(-1,1) + SRC(-1,2) + SRC(-1,3) +
  495.                                    SRC(0,-1) + SRC(1,-1) + SRC(2,-1) + SRC(3,-1) + 4) >> 3 );
  496.       PREDICT_4x4_DC( dc );
  497.   

common/predict.c:500: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 500, column 19
  498.   void x264_predict_4x4_h_c( pixel *src )
  499.   {
  500. >     SRC_X4(0,0) = PIXEL_SPLAT_X4( SRC(-1,0) );
  501.       SRC_X4(0,1) = PIXEL_SPLAT_X4( SRC(-1,1) );
  502.       SRC_X4(0,2) = PIXEL_SPLAT_X4( SRC(-1,2) );
  503.   

common/predict.c:507: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 507, column 5
  505.   void x264_predict_4x4_v_c( pixel *src )
  506.   {
  507. >     PREDICT_4x4_DC(SRC_X4(0,-1));
  508.   }
  509.   
  510.   

common/predict.c:533: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 533, column 5
  531.   static void predict_4x4_ddl_c( pixel *src )
  532.   {
  533. >     PREDICT_4x4_LOAD_TOP
  534.       PREDICT_4x4_LOAD_TOP_RIGHT
  535.       SRC(0,0)= F2(t0,t1,t2);
  536.   

common/predict.c:534: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 534, column 5
  532.   {
  533.       PREDICT_4x4_LOAD_TOP
  534. >     PREDICT_4x4_LOAD_TOP_RIGHT
  535.       SRC(0,0)= F2(t0,t1,t2);
  536.       SRC(1,0)=SRC(0,1)= F2(t1,t2,t3);
  537.   

common/predict.c:545: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 545, column 14
  543.   static void predict_4x4_ddr_c( pixel *src )
  544.   {
  545. >     int lt = SRC(-1,-1);
  546.       PREDICT_4x4_LOAD_LEFT
  547.       PREDICT_4x4_LOAD_TOP
  548.   

common/predict.c:546: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 546, column 5
  544.   {
  545.       int lt = SRC(-1,-1);
  546. >     PREDICT_4x4_LOAD_LEFT
  547.       PREDICT_4x4_LOAD_TOP
  548.       SRC(3,0)= F2(t3,t2,t1);
  549.   

common/predict.c:547: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 547, column 5
  545.       int lt = SRC(-1,-1);
  546.       PREDICT_4x4_LOAD_LEFT
  547. >     PREDICT_4x4_LOAD_TOP
  548.       SRC(3,0)= F2(t3,t2,t1);
  549.       SRC(2,0)=SRC(3,1)= F2(t2,t1,t0);
  550.   

common/predict.c:559: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 559, column 14
  557.   static void predict_4x4_vr_c( pixel *src )
  558.   {
  559. >     int lt = SRC(-1,-1);
  560.       PREDICT_4x4_LOAD_LEFT
  561.       PREDICT_4x4_LOAD_TOP
  562.   

common/predict.c:560: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 560, column 5
  558.   {
  559.       int lt = SRC(-1,-1);
  560. >     PREDICT_4x4_LOAD_LEFT
  561.       PREDICT_4x4_LOAD_TOP
  562.       SRC(0,3)= F2(l2,l1,l0);
  563.   

common/predict.c:561: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 561, column 5
  559.       int lt = SRC(-1,-1);
  560.       PREDICT_4x4_LOAD_LEFT
  561. >     PREDICT_4x4_LOAD_TOP
  562.       SRC(0,3)= F2(l2,l1,l0);
  563.       SRC(0,2)= F2(l1,l0,lt);
  564.   

common/predict.c:576: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 576, column 13
  574.   static void predict_4x4_hd_c( pixel *src )
  575.   {
  576. >     int lt= SRC(-1,-1);
  577.       PREDICT_4x4_LOAD_LEFT
  578.       PREDICT_4x4_LOAD_TOP
  579.   

common/predict.c:577: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 577, column 5
  575.   {
  576.       int lt= SRC(-1,-1);
  577. >     PREDICT_4x4_LOAD_LEFT
  578.       PREDICT_4x4_LOAD_TOP
  579.       SRC(0,3)= F1(l2,l3);
  580.   

common/predict.c:578: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 578, column 5
  576.       int lt= SRC(-1,-1);
  577.       PREDICT_4x4_LOAD_LEFT
  578. >     PREDICT_4x4_LOAD_TOP
  579.       SRC(0,3)= F1(l2,l3);
  580.       SRC(1,3)= F2(l1,l2,l3);
  581.   

common/predict.c:593: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 593, column 5
  591.   static void predict_4x4_vl_c( pixel *src )
  592.   {
  593. >     PREDICT_4x4_LOAD_TOP
  594.       PREDICT_4x4_LOAD_TOP_RIGHT
  595.       SRC(0,0)= F1(t0,t1);
  596.   

common/predict.c:594: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -28 out of bounds at line 594, column 5
  592.   {
  593.       PREDICT_4x4_LOAD_TOP
  594. >     PREDICT_4x4_LOAD_TOP_RIGHT
  595.       SRC(0,0)= F1(t0,t1);
  596.       SRC(0,1)= F2(t0,t1,t2);
  597.   

common/predict.c:609: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 609, column 5
  607.   static void predict_4x4_hu_c( pixel *src )
  608.   {
  609. >     PREDICT_4x4_LOAD_LEFT
  610.       SRC(0,0)= F1(l0,l1);
  611.       SRC(1,0)= F2(l0,l1,l2);
  612.   

common/predict.c:639: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 639, column 21
  637.       if( i_filters & MB_LEFT )
  638.       {
  639. >         edge[15] = (SRC(0,-1) + 2*SRC(-1,-1) + SRC(-1,0) + 2) >> 2;
  640.           edge[14] = ((have_lt ? SRC(-1,-1) : SRC(-1,0))
  641.                    + 2*SRC(-1,0) + SRC(-1,1) + 2) >> 2;
  642.   

common/predict.c:650: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -32 out of bounds at line 650, column 45
  648.       {
  649.           int have_tr = i_neighbor & MB_TOPRIGHT;
  650. >         edge[16] = ((have_lt ? SRC(-1,-1) : SRC(0,-1))
  651.                    + 2*SRC(0,-1) + SRC(1,-1) + 2) >> 2;
  652.           PT(1) PT(2) PT(3) PT(4) PT(5) PT(6)
  653.   

common/quant.c:60: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION
  A unary minus is applied to expression (((*bias[i]-*dct[i])**mf[i])>>16) of type unsigned int  at line 60, column 9
  58.       int nz = 0;
  59.       for( int i = 0; i < 64; i++ )
  60. >         QUANT_ONE( dct[i], mf[i], bias[i] );
  61.       return !!nz;
  62.   }
  63.   

common/quant.c:68: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION
  A unary minus is applied to expression (((*bias[i]-*dct[i])**mf[i])>>16) of type unsigned int  at line 68, column 9
  66.       int nz = 0;
  67.       for( int i = 0; i < 16; i++ )
  68. >         QUANT_ONE( dct[i], mf[i], bias[i] );
  69.       return !!nz;
  70.   }
  71.   

common/quant.c:79: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION
  A unary minus is applied to expression (((*bias[i]-*dct[j][i])**mf[i])>>16) of type unsigned int  at line 79, column 13
  77.           int nz = 0;
  78.           for( int i = 0; i < 16; i++ )
  79. >             QUANT_ONE( dct[j][i], mf[i], bias[i] );
  80.           nza |= (!!nz)<<j;
  81.       }
  82.   

common/set.c:308: warning: PRECONDITION_NOT_MET
  in call to strstr() at line 308, column 33
  306.       int i;
  307.   
  308. >     char *p = strstr( buf, name );
  309.       if( !p )
  310.       {
  311.   

common/set.c:361: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((35==0)!=0) is always false at line 361, column 17
  359.       }
  360.   
  361. >     while( (p = strchr( buf, '#' )) != NULL )
  362.           memset( p, ' ', strcspn( p, "\n" ) );
  363.   
  364.   

common/threadpool.c:86: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  ((0<0)!=0) is always false at line 86, column 9
  84.           return -1;
  85.   
  86. >     if( x264_threading_init() < 0 )
  87.           return -1;
  88.   
  89.   

common/threadpool.c:90: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 90, column 5
  88.   
  89.       x264_threadpool_t *pool;
  90. >     CHECKED_MALLOCZERO( pool, sizeof(x264_threadpool_t) );
  91.       *p_pool = pool;
  92.   
  93.   

common/threadpool.c:130: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 130, column 12
  128.   {
  129.       x264_pthread_mutex_lock( &pool->done.mutex );
  130. >     while( 1 )
  131.       {
  132.           for( int i = 0; i < pool->done.i_size; i++ )
  133.   

common/x86/predict-c.c:141: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>8)!=0) is always true at line 141, column 1
  139.   
  140.   #if HIGH_BIT_DEPTH
  141. > PREDICT_16x16_P_INLINE( sse2, sse2 )
  142.   #else // !HIGH_BIT_DEPTH
  143.   #if !ARCH_X86_64
  144.   

common/x86/predict-c.c:141: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 141, column 1
  139.   
  140.   #if HIGH_BIT_DEPTH
  141. > PREDICT_16x16_P_INLINE( sse2, sse2 )
  142.   #else // !HIGH_BIT_DEPTH
  143.   #if !ARCH_X86_64
  144.   

common/x86/predict-c.c:152: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>8)!=0) is always true at line 152, column 1
  150.   PREDICT_16x16_P_INLINE( avx, avx )
  151.   #endif // HIGH_BIT_DEPTH
  152. > PREDICT_16x16_P_INLINE( avx2, avx2 )
  153.   
  154.   #define PREDICT_8x16C_P_CORE\
  155.   

common/x86/predict-c.c:152: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -33 out of bounds at line 152, column 1
  150.   PREDICT_16x16_P_INLINE( avx, avx )
  151.   #endif // HIGH_BIT_DEPTH
  152. > PREDICT_16x16_P_INLINE( avx2, avx2 )
  153.   
  154.   #define PREDICT_8x16C_P_CORE\
  155.   

common/x86/predict-c.c:270: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 270, column 1
  268.   
  269.   #if HIGH_BIT_DEPTH
  270. > PREDICT_8x8C_P_INLINE( sse2, sse2 )
  271.   #else  //!HIGH_BIT_DEPTH
  272.   #if !ARCH_X86_64
  273.   

common/x86/predict-c.c:280: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 280, column 1
  278.   #endif // HAVE_X86_INLINE_ASM
  279.   #endif // HIGH_BIT_DEPTH
  280. > PREDICT_8x8C_P_INLINE( avx, avx )
  281.   PREDICT_8x8C_P_INLINE( avx2, avx2 )
  282.   
  283.   

common/x86/predict-c.c:281: error: ARRAY_OUT_OF_BOUNDS_L1
  array src could be accessed with index -1 out of bounds at line 281, column 1
  279.   #endif // HIGH_BIT_DEPTH
  280.   PREDICT_8x8C_P_INLINE( avx, avx )
  281. > PREDICT_8x8C_P_INLINE( avx2, avx2 )
  282.   
  283.   #if ARCH_X86_64 && !HIGH_BIT_DEPTH
  284.   

encoder/analyse.c:151: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 151, column 5
  149.       int lambda = x264_lambda_tab[qp];
  150.       /* factor of 4 from qpel, 2 from sign, and 2 because mv can be opposite from mvp */
  151. >     CHECKED_MALLOC( h->cost_mv[qp], (4*4*mv_range + 1) * sizeof(uint16_t) );
  152.       h->cost_mv[qp] += 2*4*mv_range;
  153.       for( int i = 0; i <= 2*4*mv_range; i++ )
  154.   

encoder/analyse.c:156: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->cost_mv[qp] last assigned on line 152 could be accessed with index -1 out of bounds at line 156, column 30
  154.       {
  155.           h->cost_mv[qp][-i] =
  156. >         h->cost_mv[qp][i]  = X264_MIN( (int)(lambda * logs[i] + .5f), UINT16_MAX );
  157.       }
  158.       for( int i = 0; i < 3; i++ )
  159.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][0] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][4] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][2] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][3] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:495: error: ARRAY_OUT_OF_BOUNDS_L1
  array i8x8_mode_available[1][1] could be accessed with index 1 out of bounds at line 495, column 1
  493.   
  494.   static const int8_t i8x8_mode_available[2][5][10] =
  495. > {
  496.       {
  497.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  498.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][0] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][1] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][3] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][2] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:513: error: ARRAY_OUT_OF_BOUNDS_L1
  array i4x4_mode_available[1][4] could be accessed with index 1 out of bounds at line 513, column 1
  511.   
  512.   static const int8_t i4x4_mode_available[2][5][10] =
  513. > {
  514.       {
  515.           {I_PRED_4x4_DC_128, -1, -1, -1, -1, -1, -1, -1, -1, -1},
  516.   

encoder/analyse.c:1262: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->mb.pic.p_fref[0][i_ref] of size 2 could be accessed with index 2 out of bounds at line 1262, column 9
  1260.   
  1261.           /* search with ref */
  1262. >         LOAD_HPELS( &m, h->mb.pic.p_fref[0][i_ref], 0, i_ref, 0, 0 );
  1263.           LOAD_WPELS( &m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 0, 0 );
  1264.   
  1265.   

encoder/analyse.c:1694: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_fref of size 2 last assigned on line 1675 could be accessed with an index out of bounds at line 1694, column 9
  1692.   
  1693.           LOAD_FENC( m, p_fenc, 4*x4, 4*y4 );
  1694. >         LOAD_HPELS( m, p_fref, 0, i_ref, 4*x4, 4*y4 );
  1695.           LOAD_WPELS( m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 4*x4, 4*y4 );
  1696.   
  1697.   

encoder/analyse.c:1733: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_fref of size 2 last assigned on line 1714 could be accessed with an index out of bounds at line 1733, column 9
  1731.   
  1732.           LOAD_FENC( m, p_fenc, 4*x4, 4*y4 );
  1733. >         LOAD_HPELS( m, p_fref, 0, i_ref, 4*x4, 4*y4 );
  1734.           LOAD_WPELS( m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 4*x4, 4*y4 );
  1735.   
  1736.   

encoder/analyse.c:1769: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_fref of size 2 last assigned on line 1750 could be accessed with an index out of bounds at line 1769, column 9
  1767.   
  1768.           LOAD_FENC( m, p_fenc, 4*x4, 4*y4 );
  1769. >         LOAD_HPELS( m, p_fref, 0, i_ref, 4*x4, 4*y4 );
  1770.           LOAD_WPELS( m, h->mb.pic.p_fref_w[i_ref], 0, i_ref, 4*x4, 4*y4 );
  1771.   
  1772.   

encoder/analyse.c:2146: warning: PRECONDITION_NOT_MET
  in call to x264_macroblock_cache_ref() at line 2146, column 9
  2144.       else
  2145.       {
  2146. >         CACHE_MV_BI( x, y, 2, 2, a->l0.me8x8[i], a->l1.me8x8[i], h->mb.i_sub_partition[i] );
  2147.       }
  2148.   }
  2149.   

encoder/analyse.c:2151: warning: PRECONDITION_NOT_MET
  in call to x264_macroblock_cache_ref() at line 2151, column 5
  2149.   static inline void mb_cache_mv_b16x8( x264_t *h, x264_mb_analysis_t *a, int i, int b_mvd )
  2150.   {
  2151. >     CACHE_MV_BI( 0, 2*i, 4, 2, a->l0.me16x8[i], a->l1.me16x8[i], a->i_mb_partition16x8[i] );
  2152.   }
  2153.   static inline void mb_cache_mv_b8x16( x264_t *h, x264_mb_analysis_t *a, int i, int b_mvd )
  2154.   

encoder/analyse.c:2155: warning: PRECONDITION_NOT_MET
  in call to x264_macroblock_cache_ref() at line 2155, column 5
  2153.   static inline void mb_cache_mv_b8x16( x264_t *h, x264_mb_analysis_t *a, int i, int b_mvd )
  2154.   {
  2155. >     CACHE_MV_BI( 2*i, 0, 2, 4, a->l0.me8x16[i], a->l1.me8x16[i], a->i_mb_partition8x16[i] );
  2156.   }
  2157.   #undef CACHE_MV_BI
  2158.   

encoder/analyse.c:2377: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->mb.pic.p_fref[l][i_ref] of size 2 could be accessed with an index out of bounds at line 2377, column 17
  2375.                   m.i_ref_cost = REF_COST( l, i_ref );
  2376.   
  2377. >                 LOAD_HPELS( &m, h->mb.pic.p_fref[l][i_ref], l, i_ref, 0, 8*i );
  2378.   
  2379.                   CP32( mvc[0], lX->mvc[i_ref][0] );
  2380.   

encoder/analyse.c:2471: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->mb.pic.p_fref[l][i_ref] of size 2 could be accessed with an index out of bounds at line 2471, column 17
  2469.                   m.i_ref_cost = REF_COST( l, i_ref );
  2470.   
  2471. >                 LOAD_HPELS( &m, h->mb.pic.p_fref[l][i_ref], l, i_ref, 8*i, 0 );
  2472.   
  2473.                   CP32( mvc[0], lX->mvc[i_ref][0] );
  2474.   

encoder/api.c:82: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 82, column 9
  80.           return NULL;
  81.   
  82. >     if( HAVE_BITDEPTH8 && param->i_bitdepth == 8 )
  83.       {
  84.           api->nal_encode = x264_8_nal_encode;
  85.   

encoder/api.c:97: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 97, column 14
  95.           api->x264 = x264_8_encoder_open( param );
  96.       }
  97. >     else if( HAVE_BITDEPTH10 && param->i_bitdepth == 10 )
  98.       {
  99.           api->nal_encode = x264_10_nal_encode;
  100.   

encoder/api.c:115: warning: UNINITIALIZED_VALUE
  value api->x264 was not initialized after declaration and is used at line 115, column 10
  113.           x264_log_internal( X264_LOG_ERROR, "not compiled with %d bit depth support\n", param->i_bitdepth );
  114.   
  115. >     if( !api->x264 )
  116.       {
  117.           free( api );
  118.   

encoder/cabac.c:360: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 360, column 13
  358.       {
  359.           case D_L0_8x8:
  360. >             cabac_mvd( h, cb, 0, 4*i, 2, 2 );
  361.               break;
  362.           case D_L0_8x4:
  363.   

encoder/cabac.c:363: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 363, column 13
  361.               break;
  362.           case D_L0_8x4:
  363. >             cabac_mvd( h, cb, 0, 4*i+0, 2, 1 );
  364.               cabac_mvd( h, cb, 0, 4*i+2, 2, 1 );
  365.               break;
  366.   

encoder/cabac.c:364: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 364, column 13
  362.           case D_L0_8x4:
  363.               cabac_mvd( h, cb, 0, 4*i+0, 2, 1 );
  364. >             cabac_mvd( h, cb, 0, 4*i+2, 2, 1 );
  365.               break;
  366.           case D_L0_4x8:
  367.   

encoder/cabac.c:367: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 367, column 13
  365.               break;
  366.           case D_L0_4x8:
  367. >             cabac_mvd( h, cb, 0, 4*i+0, 1, 2 );
  368.               cabac_mvd( h, cb, 0, 4*i+1, 1, 2 );
  369.               break;
  370.   

encoder/cabac.c:368: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 368, column 13
  366.           case D_L0_4x8:
  367.               cabac_mvd( h, cb, 0, 4*i+0, 1, 2 );
  368. >             cabac_mvd( h, cb, 0, 4*i+1, 1, 2 );
  369.               break;
  370.           case D_L0_4x4:
  371.   

encoder/cabac.c:716: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 716, column 13
  714.           }
  715.           else
  716. >             WRITE_SIGMAP( i, i )
  717.       }
  718.   
  719.   

encoder/cavlc.c:481: warning: PRECONDITION_NOT_MET
  in call to cavlc_mb_header_i() at line 481, column 53
  479.           bs_write1( s, 1 );
  480.       else //if( IS_INTRA( i_mb_type ) )
  481. >         cavlc_mb_header_i( h, i_mb_type, 23, chroma );
  482.   }
  483.   
  484.   

encoder/encoder.c:1354: warning: PRECONDITION_NOT_MET
  in call to memcpy() at line 1354, column 5
  1352.   {
  1353.       int satd = !h->mb.b_lossless && h->param.analyse.i_subpel_refine > 1;
  1354. >     memcpy( h->pixf.mbcmp, satd ? h->pixf.satd : h->pixf.sad_aligned, sizeof(h->pixf.mbcmp) );
  1355.       memcpy( h->pixf.mbcmp_unaligned, satd ? h->pixf.satd : h->pixf.sad, sizeof(h->pixf.mbcmp_unaligned) );
  1356.       h->pixf.intra_mbcmp_x3_16x16 = satd ? h->pixf.intra_satd_x3_16x16 : h->pixf.intra_sad_x3_16x16;
  1357.   

encoder/encoder.c:1455: warning: PRECONDITION_NOT_MET
  in call to x264_malloc() at line 1455, column 5
  1453.       int i_slicetype_length;
  1454.   
  1455. >     CHECKED_MALLOCZERO( h, sizeof(x264_t) );
  1456.   
  1457.       /* Create a copy of param */
  1458.   

encoder/encoder.c:2056: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 2056, column 21
  2054.       /* The reorder check doesn't check for missing frames, so just
  2055.        * force a reorder if one of the reference list is corrupt. */
  2056. >     for( int i = 0; h->frames.reference[i]; i++ )
  2057.           if( h->frames.reference[i]->b_corrupt )
  2058.           {
  2059.   

encoder/encoder.c:2057: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 2057, column 13
  2055.        * force a reorder if one of the reference list is corrupt. */
  2056.       for( int i = 0; h->frames.reference[i]; i++ )
  2057. >         if( h->frames.reference[i]->b_corrupt )
  2058.           {
  2059.               h->b_ref_reorder[0] = 1;
  2060.   

encoder/encoder.c:2065: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->fref[list] of size 2 could be accessed with index 2 out of bounds at line 2065, column 33
  2063.           for( int i = 0; i < h->i_ref[list] - 1; i++ )
  2064.           {
  2065. >             int framenum_diff = h->fref[list][i+1]->i_frame_num - h->fref[list][i]->i_frame_num;
  2066.               int poc_diff = h->fref[list][i+1]->i_poc - h->fref[list][i]->i_poc;
  2067.               /* P and B-frames use different default orders. */
  2068.   

encoder/encoder.c:2092: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  ((10>8)!=0) is always true at line 2092, column 9
  2090.        * With high bit depth, it's not worth doing, so turn it off except in the case of
  2091.        * unweighted dupes. */
  2092. >     if( BIT_DEPTH > 8 && w != x264_weight_none )
  2093.           return -1;
  2094.   
  2095.   

encoder/encoder.c:2120: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fenc->weighted of size 16 could be accessed with an index out of bounds at line 2120, column 68
  2118.       /* for now no analysis and set all weights to nothing */
  2119.       for( int i_ref = 0; i_ref < h->i_ref[0]; i_ref++ )
  2120. >         h->fenc->weighted[i_ref] = h->fref[0][i_ref]->filtered[0][0];
  2121.   
  2122.       // FIXME: This only supports weighting of one reference frame
  2123.   

encoder/encoder.c:2120: error: ARRAY_OUT_OF_BOUNDS_L1
  array h->fref[0] of size 2 could be accessed with index 2 out of bounds at line 2120, column 52
  2118.       /* for now no analysis and set all weights to nothing */
  2119.       for( int i_ref = 0; i_ref < h->i_ref[0]; i_ref++ )
  2120. >         h->fenc->weighted[i_ref] = h->fref[0][i_ref]->filtered[0][0];
  2121.   
  2122.       // FIXME: This only supports weighting of one reference frame
  2123.   

encoder/encoder.c:2120: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->fref[0] of size 2 could be accessed with an index out of bounds at line 2120, column 52
  2118.       /* for now no analysis and set all weights to nothing */
  2119.       for( int i_ref = 0; i_ref < h->i_ref[0]; i_ref++ )
  2120. >         h->fenc->weighted[i_ref] = h->fref[0][i_ref]->filtered[0][0];
  2121.   
  2122.       // FIXME: This only supports weighting of one reference frame
  2123.   

encoder/encoder.c:3215: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 3215, column 25
  3213.       if( pts >= h->i_last_idr_pts )
  3214.       {
  3215. >         for( int i = 0; h->frames.reference[i]; i++ )
  3216.               if( pts <= h->frames.reference[i]->i_pts )
  3217.                   h->frames.reference[i]->b_corrupt = 1;
  3218.   

encoder/encoder.c:3216: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->frames.reference of size 18 could be accessed with an index out of bounds at line 3216, column 24
  3214.       {
  3215.           for( int i = 0; h->frames.reference[i]; i++ )
  3216. >             if( pts <= h->frames.reference[i]->i_pts )
  3217.                   h->frames.reference[i]->b_corrupt = 1;
  3218.           if( pts <= h->fdec->i_pts )
  3219.   

encoder/encoder.c:4481: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 4481, column 31
  4479.       {
  4480.           for( int i = 0; i < h->i_thread_frames; i++ )
  4481. >             delayed_frames += h->thread[i]->b_thread_active;
  4482.           h = h->thread[h->i_thread_phase];
  4483.       }
  4484.   

encoder/lookahead.c:134: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 134, column 5
  132.   {
  133.       x264_lookahead_t *look;
  134. >     CHECKED_MALLOCZERO( look, sizeof(x264_lookahead_t) );
  135.       for( int i = 0; i < h->param.i_threads; i++ )
  136.           h->thread[i]->lookahead = look;
  137.   

encoder/lookahead.c:136: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 136, column 9
  134.       CHECKED_MALLOCZERO( look, sizeof(x264_lookahead_t) );
  135.       for( int i = 0; i < h->param.i_threads; i++ )
  136. >         h->thread[i]->lookahead = look;
  137.   
  138.       look->i_last_keyframe = - h->param.i_keyint_max;
  139.   

encoder/macroblock.c:569: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_dst could be accessed with index -1 out of bounds at line 569, column 36
  567.           h->mc.copy[PIXEL_4x4]( p_dst, FDEC_STRIDE, p_src-1, stride, 4 );
  568.           for( int i = 0; i < 4; i++ )
  569. >             p_dst[i*FDEC_STRIDE] = p_dst[i*FDEC_STRIDE-1];
  570.       }
  571.       else
  572.   

encoder/macroblock.c:609: error: ARRAY_OUT_OF_BOUNDS_L1
  array p_dst last assigned on line 598 could be accessed with index -1 out of bounds at line 609, column 36
  607.           h->mc.copy_16x16_unaligned( p_dst, FDEC_STRIDE, h->mb.pic.p_fenc_plane[p]-1, stride, 16 );
  608.           for( int i = 0; i < 16; i++ )
  609. >             p_dst[i*FDEC_STRIDE] = p_dst[i*FDEC_STRIDE-1];
  610.       }
  611.       else
  612.   

encoder/me.c:219: warning: PRECONDITION_NOT_MET
  in call to x264_clip3() at line 219, column 78
  217.       {
  218.           /* Calculate and check the MVP first */
  219. >         int bpred_mx = x264_clip3( m->mvp[0], SPEL(mv_x_min), SPEL(mv_x_max) );
  220.           int bpred_my = x264_clip3( m->mvp[1], SPEL(mv_y_min), SPEL(mv_y_max) );
  221.           pmv = pack16to32_mask( bpred_mx, bpred_my );
  222.   

encoder/me.c:279: warning: PRECONDITION_NOT_MET
  in call to x264_clip3() at line 279, column 69
  277.       {
  278.           /* Calculate and check the fullpel MVP first */
  279. >         bmx = pmx = x264_clip3( FPEL(m->mvp[0]), mv_x_min, mv_x_max );
  280.           bmy = pmy = x264_clip3( FPEL(m->mvp[1]), mv_y_min, mv_y_max );
  281.           pmv = pack16to32_mask( bmx, bmy );
  282.   

encoder/ratecontrol.c:559: warning: UNINITIALIZED_VALUE
  value i_type was not initialized after declaration and is used at line 559, column 21
  557.                       goto fail;
  558.   
  559. >                 if( i_type != i_type_actual && rc->mbtree.qpbuf_pos == 1 )
  560.                   {
  561.                       x264_log( h, X264_LOG_ERROR, "MB-tree frametype %d doesn't match actual frametype %d.\n", i_type, i_type_actual );
  562.   

encoder/ratecontrol.c:1266: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 1266, column 9
  1264.       {
  1265.           char *psz_zones, *p;
  1266. >         CHECKED_MALLOC( psz_zones, strlen( h->param.rc.psz_zones )+1 );
  1267.           strcpy( psz_zones, h->param.rc.psz_zones );
  1268.           h->param.rc.i_zones = 1;
  1269.   

encoder/ratecontrol.c:1807: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1807, column 9
  1805.   
  1806.       if( rce->i_weight_denom[0] >= 0 )
  1807. >         SET_WEIGHT( frm->weight[0][0], 1, rce->weight[0][0], rce->i_weight_denom[0], rce->weight[0][1] );
  1808.   
  1809.       if( rce->i_weight_denom[1] >= 0 )
  1810.   

encoder/ratecontrol.c:1811: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1811, column 9
  1809.       if( rce->i_weight_denom[1] >= 0 )
  1810.       {
  1811. >         SET_WEIGHT( frm->weight[0][1], 1, rce->weight[1][0], rce->i_weight_denom[1], rce->weight[1][1] );
  1812.           SET_WEIGHT( frm->weight[0][2], 1, rce->weight[2][0], rce->i_weight_denom[1], rce->weight[2][1] );
  1813.       }
  1814.   

encoder/ratecontrol.c:1812: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 1812, column 9
  1810.       {
  1811.           SET_WEIGHT( frm->weight[0][1], 1, rce->weight[1][0], rce->i_weight_denom[1], rce->weight[1][1] );
  1812. >         SET_WEIGHT( frm->weight[0][2], 1, rce->weight[2][0], rce->i_weight_denom[1], rce->weight[2][1] );
  1813.       }
  1814.   }
  1815.   

encoder/ratecontrol.c:2641: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 2641, column 22
  2639.       double totalsize = 0;
  2640.       for( int i = 0; i < h->param.i_threads; i++ )
  2641. >         totalsize += h->thread[i]->rc->slice_size_planned;
  2642.       double factor = h->rc->frame_size_planned / totalsize;
  2643.       for( int i = 0; i < h->param.i_threads; i++ )
  2644.   

encoder/ratecontrol.c:2642: error: DIVIDE_BY_ZERO
  Expression totalsize could be zero at line 2642, column 5
  2640.       for( int i = 0; i < h->param.i_threads; i++ )
  2641.           totalsize += h->thread[i]->rc->slice_size_planned;
  2642. >     double factor = h->rc->frame_size_planned / totalsize;
  2643.       for( int i = 0; i < h->param.i_threads; i++ )
  2644.           h->thread[i]->rc->slice_size_planned *= factor;
  2645.   

encoder/ratecontrol.c:2658: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->thread of size 129 could be accessed with an index out of bounds at line 2658, column 25
  2656.           for( int i = 0; i < h->param.i_threads; i++ )
  2657.           {
  2658. >             x264_t *t = h->thread[i];
  2659.               if( t != h )
  2660.                   memcpy( t->rc->row_preds, rc->row_preds, sizeof(rc->row_preds) );
  2661.   

encoder/ratecontrol.c:2857: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 2857, column 5
  2855.       int iterations = 0;
  2856.       int adj_min, adj_max;
  2857. >     CHECKED_MALLOC( fills, (rcc->num_entries+1)*sizeof(double) );
  2858.   
  2859.       fills++;
  2860.   

encoder/ratecontrol.c:2881: error: ARRAY_OUT_OF_BOUNDS_L1
  array fills last assigned on line 2859 could be accessed with index -1 out of bounds at line 2881, column 75
  2879.           }
  2880.   
  2881. >         fills[-1] = rcc->buffer_size * (1. - h->param.rc.f_vbv_buffer_init);
  2882.           t0 = 0;
  2883.           /* fix underflows -- should be done after overflow, as we'd better undersize target than underflowing VBV */
  2884.   

encoder/rdo.c:583: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 583, column 5
  581.   {
  582.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  583. >     COEF( 1, 0, 0, 1, 1, 0 );
  584.       COEF( 1, 0, 1, 2, 2, 0 );
  585.       COEF( 1, 0, 2, 3, 3, 0 );
  586.   

encoder/rdo.c:584: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 584, column 5
  582.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  583.       COEF( 1, 0, 0, 1, 1, 0 );
  584. >     COEF( 1, 0, 1, 2, 2, 0 );
  585.       COEF( 1, 0, 2, 3, 3, 0 );
  586.       COEF( 1, 0, 3, 3, 4, 0 );
  587.   

encoder/rdo.c:585: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 585, column 5
  583.       COEF( 1, 0, 0, 1, 1, 0 );
  584.       COEF( 1, 0, 1, 2, 2, 0 );
  585. >     COEF( 1, 0, 2, 3, 3, 0 );
  586.       COEF( 1, 0, 3, 3, 4, 0 );
  587.       return levels_used;
  588.   

encoder/rdo.c:586: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 586, column 5
  584.       COEF( 1, 0, 1, 2, 2, 0 );
  585.       COEF( 1, 0, 2, 3, 3, 0 );
  586. >     COEF( 1, 0, 3, 3, 4, 0 );
  587.       return levels_used;
  588.   }
  589.   

encoder/rdo.c:597: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 597, column 5
  595.   {
  596.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  597. >     COEF( 1, 1, 1, 2, 2, 0 );
  598.       COEF( 1, 1, 2, 3, 3, 0 );
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600.   

encoder/rdo.c:598: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 598, column 5
  596.       int abs_level = 1, prefix = 1, suffix_cost = 0;
  597.       COEF( 1, 1, 1, 2, 2, 0 );
  598. >     COEF( 1, 1, 2, 3, 3, 0 );
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601.   

encoder/rdo.c:599: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 599, column 5
  597.       COEF( 1, 1, 1, 2, 2, 0 );
  598.       COEF( 1, 1, 2, 3, 3, 0 );
  599. >     COEF( 1, 1, 3, 3, 4, 0 );
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602.   

encoder/rdo.c:600: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (4!=0) is always true at line 600, column 5
  598.       COEF( 1, 1, 2, 3, 3, 0 );
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600. >     COEF( 1, 1, 4, 4, 0, 0 );
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602.       COEF( 1, 1, 6, 6, 0, 0 );
  603.   

encoder/rdo.c:601: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (5!=0) is always true at line 601, column 5
  599.       COEF( 1, 1, 3, 3, 4, 0 );
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601. >     COEF( 1, 1, 5, 5, 0, 0 );
  602.       COEF( 1, 1, 6, 6, 0, 0 );
  603.       COEF( 1, 1, 7, 7, 0, 0 );
  604.   

encoder/rdo.c:602: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (6!=0) is always true at line 602, column 5
  600.       COEF( 1, 1, 4, 4, 0, 0 );
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602. >     COEF( 1, 1, 6, 6, 0, 0 );
  603.       COEF( 1, 1, 7, 7, 0, 0 );
  604.       return levels_used;
  605.   

encoder/rdo.c:603: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (7!=0) is always true at line 603, column 5
  601.       COEF( 1, 1, 5, 5, 0, 0 );
  602.       COEF( 1, 1, 6, 6, 0, 0 );
  603. >     COEF( 1, 1, 7, 7, 0, 0 );
  604.       return levels_used;
  605.   }
  606.   

encoder/rdo.c:615: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 615, column 5
  613.       int prefix = X264_MIN( abs_level-1, 14 );
  614.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  615. >     COEF( 2, 0, 0, 4, 1, 5 );
  616.       COEF( 2, 0, 1, 4, 2, 5 );
  617.       COEF( 2, 0, 2, 4, 3, 5 );
  618.   

encoder/rdo.c:616: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 616, column 5
  614.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  615.       COEF( 2, 0, 0, 4, 1, 5 );
  616. >     COEF( 2, 0, 1, 4, 2, 5 );
  617.       COEF( 2, 0, 2, 4, 3, 5 );
  618.       COEF( 2, 0, 3, 4, 4, 5 );
  619.   

encoder/rdo.c:617: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 617, column 5
  615.       COEF( 2, 0, 0, 4, 1, 5 );
  616.       COEF( 2, 0, 1, 4, 2, 5 );
  617. >     COEF( 2, 0, 2, 4, 3, 5 );
  618.       COEF( 2, 0, 3, 4, 4, 5 );
  619.       return levels_used;
  620.   

encoder/rdo.c:618: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 618, column 5
  616.       COEF( 2, 0, 1, 4, 2, 5 );
  617.       COEF( 2, 0, 2, 4, 3, 5 );
  618. >     COEF( 2, 0, 3, 4, 4, 5 );
  619.       return levels_used;
  620.   }
  621.   

encoder/rdo.c:630: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 630, column 5
  628.       int prefix = X264_MIN( abs_level-1, 14 );
  629.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  630. >     COEF( 2, 1, 1, 4, 2, 5 );
  631.       COEF( 2, 1, 2, 4, 3, 5 );
  632.       COEF( 2, 1, 3, 4, 4, 5 );
  633.   

encoder/rdo.c:631: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (2!=0) is always true at line 631, column 5
  629.       int suffix_cost = abs_level >= 15 ? bs_size_ue_big( abs_level - 15 ) << CABAC_SIZE_BITS : 0;
  630.       COEF( 2, 1, 1, 4, 2, 5 );
  631. >     COEF( 2, 1, 2, 4, 3, 5 );
  632.       COEF( 2, 1, 3, 4, 4, 5 );
  633.       COEF( 2, 1, 4, 5, 0, 6 );
  634.   

encoder/rdo.c:632: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (3!=0) is always true at line 632, column 5
  630.       COEF( 2, 1, 1, 4, 2, 5 );
  631.       COEF( 2, 1, 2, 4, 3, 5 );
  632. >     COEF( 2, 1, 3, 4, 4, 5 );
  633.       COEF( 2, 1, 4, 5, 0, 6 );
  634.       COEF( 2, 1, 5, 6, 0, 7 );
  635.   

encoder/rdo.c:633: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (4!=0) is always true at line 633, column 5
  631.       COEF( 2, 1, 2, 4, 3, 5 );
  632.       COEF( 2, 1, 3, 4, 4, 5 );
  633. >     COEF( 2, 1, 4, 5, 0, 6 );
  634.       COEF( 2, 1, 5, 6, 0, 7 );
  635.       COEF( 2, 1, 6, 7, 0, 8 );
  636.   

encoder/set.c:40: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 40, column 13
  38.       for( int i = 0; i < w; i++ )
  39.           for( int j = 0; j < i; j++ )
  40. >             XCHG( uint8_t, buf[w*i+j], buf[w*j+i] );
  41.   }
  42.   
  43.   

encoder/set.c:597: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 597, column 5
  595.       if( !opts )
  596.           return -1;
  597. >     CHECKED_MALLOC( payload, 200 + strlen( opts ) );
  598.   
  599.       memcpy( payload, uuid, 16 );
  600.   

encoder/set.c:602: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 602, column 40
  600.       sprintf( payload+16, "x264 - core %d%s - H.264/MPEG-4 AVC codec - "
  601.                "Copy%s 2003-2019 - http://www.videolan.org/x264.html - options: %s",
  602. >              X264_BUILD, X264_VERSION, HAVE_GPL?"left":"right", opts );
  603.       length = strlen(payload)+1;
  604.   
  605.   

encoder/slicetype-cl.c:67: warning: ARRAY_OUT_OF_BOUNDS_L2
  array h->opencl.copies of size 1024 could be accessed with an index out of bounds at line 67, column 17
  65.        * their final destination */
  66.       for( int i = 0; i < h->opencl.num_copies; i++ )
  67. >         memcpy( h->opencl.copies[i].dest, h->opencl.copies[i].src, h->opencl.copies[i].bytes );
  68.       h->opencl.num_copies = 0;
  69.       h->opencl.pl_occupancy = 0;
  70.   

encoder/slicetype-cl.c:572: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 572, column 5
  570.   
  571.       cl_uint arg = 0;
  572. >     OCLCHECK( clSetKernelArg, h->opencl.mode_select_kernel, arg++, sizeof(cl_mem), &fenc->opencl.scaled_image2Ds[0] );
  573.       OCLCHECK( clSetKernelArg, h->opencl.mode_select_kernel, arg++, sizeof(cl_mem), &fref0->opencl.luma_hpel );
  574.       OCLCHECK( clSetKernelArg, h->opencl.mode_select_kernel, arg++, sizeof(cl_mem), &fref1->opencl.luma_hpel );
  575.   

encoder/slicetype.c:291: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 291, column 5
  289.       const float epsilon = 1.f/128.f;
  290.       x264_weight_t *weights = fenc->weight[0];
  291. >     SET_WEIGHT( weights[0], 0, 1, 0, 0 );
  292.       SET_WEIGHT( weights[1], 0, 1, 0, 0 );
  293.       SET_WEIGHT( weights[2], 0, 1, 0, 0 );
  294.   

encoder/slicetype.c:292: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 292, column 5
  290.       x264_weight_t *weights = fenc->weight[0];
  291.       SET_WEIGHT( weights[0], 0, 1, 0, 0 );
  292. >     SET_WEIGHT( weights[1], 0, 1, 0, 0 );
  293.       SET_WEIGHT( weights[2], 0, 1, 0, 0 );
  294.       int chroma_initted = 0;
  295.   

encoder/slicetype.c:293: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 293, column 5
  291.       SET_WEIGHT( weights[0], 0, 1, 0, 0 );
  292.       SET_WEIGHT( weights[1], 0, 1, 0, 0 );
  293. >     SET_WEIGHT( weights[2], 0, 1, 0, 0 );
  294.       int chroma_initted = 0;
  295.       float guess_scale[3];
  296.   

encoder/slicetype.c:1404: error: DIVIDE_BY_ZERO
  Expression (h->param.i_keyint_max-h->param.i_keyint_min) could be zero at line 1404, column 9
  1402.       else
  1403.       {
  1404. >         f_bias = f_thresh_min
  1405.                    + ( f_thresh_max - f_thresh_min )
  1406.                    * ( i_gop_size - h->param.i_keyint_min )
  1407.   

filters/video/cache.c:68: error: MEMORY_LEAK
   memory dynamically allocated to return by call to calloc() at line 60, column 22 is not reachable after line 68, column 9
  66.       h->cache = malloc( (h->max_size+1) * sizeof(cli_pic_t*) );
  67.       if( !h->cache ) {
  68. >         return -1;
  69.       }
  70.   
  71.   

filters/video/cache.c:74: error: MEMORY_LEAK
   memory dynamically allocated to h by call to calloc() at line 60, column 22 is not reachable after line 74, column 29
  72.       {
  73.           h->cache[i] = malloc( sizeof(cli_pic_t) );
  74. >         if( !h->cache[i] || x264_cli_pic_alloc( h->cache[i], info->csp, info->width, info->height ) ) {
  75.               return -1; 
  76.           }
  77.   

filters/video/cache.c:127: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 127, column 5
  125.   {
  126.       cache_hnd_t *h = handle;
  127. >     FAIL_IF_ERR( frame < h->first_frame, NAME, "frame %d is before first cached frame %d \n", frame, h->first_frame );
  128.       fill_cache( h, frame );
  129.       if( frame > LAST_FRAME ) /* eof */
  130.   

filters/video/crop.c:56: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 56, column 9
  54.       {
  55.           char *opt = x264_get_option( optlist[i], opts );
  56. >         FAIL_IF_ERROR( !opt, "%s crop value not specified\n", optlist[i] );
  57.           h->dims[i] = x264_otoi( opt, -1 );
  58.           FAIL_IF_ERROR( h->dims[i] < 0, "%s crop value `%s' is less than 0\n", optlist[i], opt );
  59.   

filters/video/crop.c:57: warning: PRECONDITION_NOT_MET
  in call to x264_otoi() at line 57, column 22
  55.           char *opt = x264_get_option( optlist[i], opts );
  56.           FAIL_IF_ERROR( !opt, "%s crop value not specified\n", optlist[i] );
  57. >         h->dims[i] = x264_otoi( opt, -1 );
  58.           FAIL_IF_ERROR( h->dims[i] < 0, "%s crop value `%s' is less than 0\n", optlist[i], opt );
  59.           int dim_mod = i&1 ? (h->csp->mod_height << info->interlaced) : h->csp->mod_width;
  60.   

filters/video/crop.c:67: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 67, column 5
  65.   static int init( hnd_t *handle, cli_vid_filter_t *filter, video_info_t *info, x264_param_t *param, char *opt_string )
  66.   {
  67. >     FAIL_IF_ERROR( x264_cli_csp_is_invalid( info->csp ), "invalid csp %d\n", info->csp );
  68.       crop_hnd_t *h = calloc( 1, sizeof(crop_hnd_t) );
  69.       if( !h )
  70.   

filters/video/crop.c:81: error: MEMORY_LEAK
   memory dynamically allocated to return by call to calloc() at line 68, column 21 is not reachable after line 81, column 9
  79.       free( opts );
  80.       if( err )
  81. >         return -1;
  82.   
  83.       h->dims[2] = info->width  - h->dims[0] - h->dims[2];
  84.   

filters/video/crop.c:85: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 85, column 5
  83.       h->dims[2] = info->width  - h->dims[0] - h->dims[2];
  84.       h->dims[3] = info->height - h->dims[1] - h->dims[3];
  85. >     FAIL_IF_ERROR( h->dims[2] <= 0 || h->dims[3] <= 0, "invalid output resolution %dx%d\n", h->dims[2], h->dims[3] );
  86.   
  87.       if( info->width != h->dims[2] || info->height != h->dims[3] )
  88.   

filters/video/crop.c:85: error: MEMORY_LEAK
   memory dynamically allocated to h by call to calloc() at line 68, column 21 is not reachable after line 85, column 5
  83.       h->dims[2] = info->width  - h->dims[0] - h->dims[2];
  84.       h->dims[3] = info->height - h->dims[1] - h->dims[3];
  85. >     FAIL_IF_ERROR( h->dims[2] <= 0 || h->dims[3] <= 0, "invalid output resolution %dx%d\n", h->dims[2], h->dims[3] );
  86.   
  87.       if( info->width != h->dims[2] || info->height != h->dims[3] )
  88.   

filters/video/depth.c:218: warning: PRECONDITION_NOT_MET
  in call to x264_otoi() at line 218, column 25
  216.           {
  217.               char *str_bit_depth = x264_get_option( "bit_depth", opts );
  218. >             bit_depth = x264_otoi( str_bit_depth, -1 );
  219.   
  220.               ret = bit_depth < 8 || bit_depth > 16;
  221.   

filters/video/depth.c:229: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 229, column 5
  227.       }
  228.   
  229. >     FAIL_IF_ERROR( bit_depth != BIT_DEPTH, "this filter supports only bit depth %d\n", BIT_DEPTH );
  230.       FAIL_IF_ERROR( ret, "unsupported bit depth conversion.\n" );
  231.   
  232.   

filters/video/depth.c:230: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 230, column 5
  228.   
  229.       FAIL_IF_ERROR( bit_depth != BIT_DEPTH, "this filter supports only bit depth %d\n", BIT_DEPTH );
  230. >     FAIL_IF_ERROR( ret, "unsupported bit depth conversion.\n" );
  231.   
  232.       /* only add the filter to the chain if it's needed */
  233.   

filters/video/depth.c:235: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 235, column 9
  233.       if( change_fmt || bit_depth != 8 * x264_cli_csp_depth_factor( csp ) )
  234.       {
  235. >         FAIL_IF_ERROR( !depth_filter_csp_is_supported(csp), "unsupported colorspace.\n" );
  236.           depth_hnd_t *h = x264_malloc( sizeof(depth_hnd_t) + (info->width+1)*sizeof(int16_t) );
  237.   
  238.   

filters/video/internal.c:43: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 43, column 5
  41.   {
  42.       int csp = in->img.csp & X264_CSP_MASK;
  43. >     FAIL_IF_ERROR( x264_cli_csp_is_invalid( in->img.csp ), "invalid colorspace arg %d\n", in->img.csp );
  44.       FAIL_IF_ERROR( in->img.csp != out->img.csp || in->img.height != out->img.height
  45.                   || in->img.width != out->img.width, "incompatible frame properties\n" );
  46.   

filters/video/internal.c:44: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 44, column 5
  42.       int csp = in->img.csp & X264_CSP_MASK;
  43.       FAIL_IF_ERROR( x264_cli_csp_is_invalid( in->img.csp ), "invalid colorspace arg %d\n", in->img.csp );
  44. >     FAIL_IF_ERROR( in->img.csp != out->img.csp || in->img.height != out->img.height
  45.                   || in->img.width != out->img.width, "incompatible frame properties\n" );
  46.       /* copy data */
  47.   

filters/video/select_every.c:68: warning: PRECONDITION_NOT_MET
  in call to x264_otoi() at line 68, column 38
  66.       for( char *tok, *p = opt_string, UNUSED *saveptr = NULL; (tok = strtok_r( p, ",", &saveptr )); p = NULL )
  67.       {
  68. >         int val = x264_otoi( tok, -1 );
  69.           if( p )
  70.           {
  71.   

filters/video/select_every.c:79: error: MEMORY_LEAK
   memory dynamically allocated by call to malloc() at line 60, column 52 is not reachable after line 79, column 5
  77.           offsets[h->pattern_len++] = val;
  78.       }
  79. >     FAIL_IF_ERROR( !h->step_size, "no step size provided\n" );
  80.       FAIL_IF_ERROR( !h->pattern_len, "no offsets supplied\n" );
  81.   
  82.   

filters/video/source.c:49: error: MEMORY_LEAK
   memory dynamically allocated to return by call to calloc() at line 42, column 23 is not reachable after line 49, column 9
  47.   
  48.       if( cli_input.picture_alloc( &h->pic, *handle, info->csp, info->width, info->height ) ) {
  49. >         return -1;
  50.       }
  51.   
  52.   

filters/video/video.c:51: warning: PRECONDITION_NOT_MET
  in call to register_vid_filter() at line 51, column 5
  49.   #if HAVE_BITDEPTH8
  50.       REGISTER_VFILTER( cache_8 );
  51. >     REGISTER_VFILTER( depth_8 );
  52.   #endif
  53.   #if HAVE_BITDEPTH10
  54.   

filters/video/video.c:71: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 71, column 5
  69.       while( filter_i && strcasecmp( name, filter_i->name ) )
  70.           filter_i = filter_i->next;
  71. >     FAIL_IF_ERR( !filter_i, "x264", "invalid filter `%s'\n", name );
  72.       if( filter_i->init( handle, filter, info, param, opt_string ) )
  73.           return -1;
  74.   

input/avs.c:134: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 134, column 5
  132.       if( !h->library )
  133.           return -1;
  134. >     LOAD_AVS_FUNC( avs_clip_get_error, 0 );
  135.       LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.   

input/avs.c:135: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 135, column 5
  133.           return -1;
  134.       LOAD_AVS_FUNC( avs_clip_get_error, 0 );
  135. >     LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138.   

input/avs.c:136: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 136, column 5
  134.       LOAD_AVS_FUNC( avs_clip_get_error, 0 );
  135.       LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136. >     LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.   

input/avs.c:137: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 137, column 5
  135.       LOAD_AVS_FUNC( avs_create_script_environment, 0 );
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137. >     LOAD_AVS_FUNC( avs_get_error, 1 );
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.       LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140.   

input/avs.c:138: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 138, column 5
  136.       LOAD_AVS_FUNC( avs_delete_script_environment, 1 );
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138. >     LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.       LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140.       LOAD_AVS_FUNC( avs_function_exists, 0 );
  141.   

input/avs.c:139: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 139, column 5
  137.       LOAD_AVS_FUNC( avs_get_error, 1 );
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139. >     LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140.       LOAD_AVS_FUNC( avs_function_exists, 0 );
  141.       LOAD_AVS_FUNC( avs_invoke, 0 );
  142.   

input/avs.c:140: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 140, column 5
  138.       LOAD_AVS_FUNC( avs_get_frame, 0 );
  139.       LOAD_AVS_FUNC( avs_get_video_info, 0 );
  140. >     LOAD_AVS_FUNC( avs_function_exists, 0 );
  141.       LOAD_AVS_FUNC( avs_invoke, 0 );
  142.       LOAD_AVS_FUNC( avs_release_clip, 0 );
  143.   

input/avs.c:225: warning: ARRAY_OUT_OF_BOUNDS_L2
  array all_purpose of size 2 could be accessed with an index out of bounds at line 225, column 21
  223.           filter[i++] = "AVCSource";
  224.   #endif
  225. >     for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226.           filter[i++] = all_purpose[j];
  227.   }
  228.   

input/avs.c:225: error: ARRAY_OUT_OF_BOUNDS_L1
  array all_purpose of size 2 could be accessed with an index out of bounds at line 225, column 21
  223.           filter[i++] = "AVCSource";
  224.   #endif
  225. >     for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226.           filter[i++] = all_purpose[j];
  227.   }
  228.   

input/avs.c:226: error: ARRAY_OUT_OF_BOUNDS_L1
  array all_purpose of size 2 could be accessed with an index out of bounds at line 226, column 23
  224.   #endif
  225.       for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226. >         filter[i++] = all_purpose[j];
  227.   }
  228.   
  229.   

input/avs.c:226: warning: ARRAY_OUT_OF_BOUNDS_L2
  array all_purpose of size 2 could be accessed with an index out of bounds at line 226, column 23
  224.   #endif
  225.       for( int j = 0; all_purpose[j] && i < AVS_MAX_SEQUENCE; j++ )
  226. >         filter[i++] = all_purpose[j];
  227.   }
  228.   
  229.   

input/avs.c:265: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 265, column 5
  263.       int b_regular = x264_is_regular_file( fh );
  264.       fclose( fh );
  265. >     FAIL_IF_ERROR( !b_regular, "AVS input is incompatible with non-regular file `%s'\n", psz_filename );
  266.   
  267.       avs_hnd_t *h = calloc( 1, sizeof(avs_hnd_t) );
  268.   

input/avs.c:272: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 272, column 5
  270.       }
  271.       __efffix_tmp = custom_avs_load_library( h );
  272. >     FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273.       h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.   

input/avs.c:272: error: MEMORY_LEAK
   memory dynamically allocated by call to calloc() at line 267, column 20 is not reachable after line 272, column 5
  270.       }
  271.       __efffix_tmp = custom_avs_load_library( h );
  272. >     FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273.       h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.   

input/avs.c:273: warning: UNINITIALIZED_VALUE
  value h->func.avs_create_script_environment was not initialized after declaration and is used at line 273, column 14
  271.       __efffix_tmp = custom_avs_load_library( h );
  272.       FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273. >     h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.       {
  276.   

input/avs.c:273: error: DANGLING_POINTER_DEREFERENCE
  uninitialized pointer h->func.avs_create_script_environment could be dangling and is dereferenced or freed at line 273, column 14
  271.       __efffix_tmp = custom_avs_load_library( h );
  272.       FAIL_IF_ERROR( __efffix_tmp, "failed to load avisynth\n" );
  273. >     h->env = h->func.avs_create_script_environment( AVS_INTERFACE_25 );
  274.       if( h->func.avs_get_error )
  275.       {
  276.   

input/avs.c:515: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 515, column 5
  513.       AVS_VideoFrame *frm = pic->opaque = h->func.avs_get_frame( h->clip, i_frame );
  514.       const char *err = h->func.avs_clip_get_error( h->clip );
  515. >     FAIL_IF_ERROR( err, "%s occurred while reading frame %d\n", err, i_frame );
  516.       for( int i = 0; i < pic->img.planes; i++ )
  517.       {
  518.   

input/input.c:138: warning: ARRAY_OUT_OF_BOUNDS_L2
  array pic->img.plane of size 4 could be accessed with an index out of bounds at line 138, column 20
  136.   {
  137.       for( int i = 0; i < pic->img.planes; i++ )
  138. >         x264_free( pic->img.plane[i] );
  139.       memset( pic, 0, sizeof(cli_pic_t) );
  140.   }
  141.   

input/raw.c:45: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 45, column 49
  43.   static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
  44.   {
  45. >     raw_hnd_t *h = calloc( 1, sizeof(raw_hnd_t) );
  46.       if( !h )
  47.           return -1;
  48.   

input/thread.c:56: error: MEMORY_LEAK
   memory dynamically allocated to h by call to malloc() at line 54, column 23 is not reachable after line 56, column 5
  54.       thread_hnd_t *h = malloc( sizeof(thread_hnd_t) );
  55.       __efffix_tmp = cli_input.picture_alloc( &h->pic, *p_handle, info->csp, info->width, info->height );
  56. >     FAIL_IF_ERR( !h || __efffix_tmp,
  57.                    "x264", "malloc failed\n" );
  58.       h->input = cli_input;
  59.   

input/thread.c:56: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 56, column 5
  54.       thread_hnd_t *h = malloc( sizeof(thread_hnd_t) );
  55.       __efffix_tmp = cli_input.picture_alloc( &h->pic, *p_handle, info->csp, info->width, info->height );
  56. >     FAIL_IF_ERR( !h || __efffix_tmp,
  57.                    "x264", "malloc failed\n" );
  58.       h->input = cli_input;
  59.   

input/thread.c:63: error: MEMORY_LEAK
   memory dynamically allocated to return by call to malloc() at line 54, column 23 is not reachable after line 63, column 9
  61.       h->next_args = malloc( sizeof(thread_input_arg_t) );
  62.       if( !h->next_args ) {
  63. >         return -1;
  64.       }
  65.       h->next_args->h = h;
  66.   

input/thread.c:69: warning: PRECONDITION_NOT_MET
  in call to x264_10_threadpool_init() at line 69, column 9
  67.       h->frame_total = info->num_frames;
  68.   
  69. >     if( x264_threadpool_init( &h->pool, 1, NULL, NULL ) ) {
  70.           return -1;
  71.       }
  72.   

input/timecode.c:60: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 60, column 12
  58.       double exponent;
  59.       double fps_sig = sigexp10( fps, &exponent );
  60. >     while( 1 )
  61.       {
  62.           fps_den = i * h->timebase_num;
  63.   

input/timecode.c:64: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 64, column 9
  62.           fps_den = i * h->timebase_num;
  63.           fps_num = round( fps_den * fps_sig ) * exponent;
  64. >         FAIL_IF_ERROR( fps_num > UINT32_MAX, "tcfile fps correction failed.\n"
  65.                          "                  Specify an appropriate timebase manually or remake tcfile.\n" );
  66.           if( fabs( ((double)fps_num / fps_den) / exponent - fps_sig ) < DOUBLE_EPSILON )
  67.   

input/timecode.c:90: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 90, column 9
  88.           fps_den = round( MKV_TIMEBASE_DEN / fps_sig ) / exponent;
  89.           h->timebase_num = fps_den && h->timebase_num ? gcd( h->timebase_num, fps_den ) : fps_den;
  90. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || !h->timebase_num, "automatic timebase generation failed.\n"
  91.                          "                  Specify timebase manually.\n" );
  92.       }
  93.   

input/timecode.c:104: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 104, column 5
  102.   
  103.       ret = fscanf( tcfile_in, "# timecode format v%d", &tcfv );
  104. >     FAIL_IF_ERROR( ret != 1 || (tcfv != 1 && tcfv != 2), "unsupported timecode format\n" );
  105.   #define NO_TIMECODE_LINE (buff[0] == '#' || buff[0] == '\n' || buff[0] == '\r')
  106.       if( tcfv == 1 )
  107.   

input/timecode.c:348: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 348, column 5
  346.       FILE *tcfile_in;
  347.       timecode_hnd_t *h = malloc( sizeof(timecode_hnd_t) );
  348. >     FAIL_IF_ERROR( !h, "malloc failed\n" );
  349.       h->input = cli_input;
  350.       h->p_handle = *p_handle;
  351.   

input/timecode.c:360: warning: UNINITIALIZED_VALUE
  value h->timebase_den was not initialized after declaration and is used at line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/timecode.c:360: error: MEMORY_LEAK
   memory dynamically allocated to h by call to malloc() at line 347, column 56 is not reachable after line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/timecode.c:360: warning: UNINITIALIZED_VALUE
  value h->timebase_num was not initialized after declaration and is used at line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/timecode.c:360: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 360, column 9
  358.               h->timebase_den = 0; /* set later by auto timebase generation */
  359.           }
  360. >         FAIL_IF_ERROR( h->timebase_num > UINT32_MAX || h->timebase_den > UINT32_MAX,
  361.                          "timebase you specified exceeds H.264 maximum\n" );
  362.       }
  363.   

input/y4m.c:73: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 73, column 20
  71.   static int open_file( char *psz_filename, hnd_t *p_handle, video_info_t *info, cli_input_opt_t *opt )
  72.   {
  73. >     y4m_hnd_t *h = calloc( 1, sizeof(y4m_hnd_t) );
  74.       int i;
  75.       uint32_t n, d;
  76.   

input/y4m.c:269: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 269, column 9
  267.           while( i <= MAX_FRAME_HEADER && fgetc( h->fh ) != '\n' )
  268.               i++;
  269. >         FAIL_IF_ERROR( i > MAX_FRAME_HEADER, "bad frame header length\n" );
  270.       }
  271.       FAIL_IF_ERROR( memcmp( header, Y4M_FRAME_MAGIC, slen ), "bad frame header magic\n" );
  272.   

output/flv.c:156: warning: PRECONDITION_NOT_MET
  in call to flv_rewrite_amf_be24() at line 156, column 5
  154.   
  155.       unsigned length = c->d_cur - start;
  156. >     flv_rewrite_amf_be24( c, length - 10, start );
  157.   
  158.       flv_put_be32( c, length + 1 ); // tag length
  159.   

output/flv.c:222: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 222, column 5
  220.       flv_rewrite_amf_be24( c, length, p_flv->start - 10 );
  221.       flv_put_be32( c, length + 11 ); // Last tag size
  222. >     CHECK( flv_flush_data( c ) );
  223.   
  224.       return sei_size + sps_size + pps_size;
  225.   

output/flv.c:323: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 323, column 5
  321.       flv_buffer *c = p_flv->c;
  322.   
  323. >     CHECK( flv_flush_data( c ) );
  324.   
  325.       double total_duration;
  326.   

output/flv_bytestream.c:90: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 90, column 21
  88.   flv_buffer *flv_create_writer( const char *filename )
  89.   {
  90. >     flv_buffer *c = calloc( 1, sizeof(flv_buffer) );
  91.       if( !c )
  92.           return NULL;
  93.   

output/matroska_ebml.c:168: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 168, column 5
  166.           return 0;
  167.   
  168. >     CHECK( mk_write_id( c->parent, c->id ) );
  169.       CHECK( mk_append_context_data( c->parent, &ff, 1 ) );
  170.   
  171.   

output/matroska_ebml.c:169: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 169, column 5
  167.   
  168.       CHECK( mk_write_id( c->parent, c->id ) );
  169. >     CHECK( mk_append_context_data( c->parent, &ff, 1 ) );
  170.   
  171.       c->id = 0;
  172.   

output/matroska_ebml.c:182: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 182, column 9
  180.   
  181.       if( c->parent )
  182. >         CHECK( mk_append_context_data( c->parent, c->data, c->d_cur ) );
  183.       else if( fwrite( c->data, c->d_cur, 1, c->owner->fp ) != 1 )
  184.           return -1;
  185.   

output/matroska_ebml.c:195: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 195, column 9
  193.       if( c->id )
  194.       {
  195. >         CHECK( mk_write_id( c->parent, c->id ) );
  196.           CHECK( mk_write_size( c->parent, c->d_cur ) );
  197.       }
  198.   

output/matroska_ebml.c:196: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 196, column 9
  194.       {
  195.           CHECK( mk_write_id( c->parent, c->id ) );
  196. >         CHECK( mk_write_size( c->parent, c->d_cur ) );
  197.       }
  198.   
  199.   

output/matroska_ebml.c:238: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 238, column 5
  236.       size_t len = strlen( str );
  237.   
  238. >     CHECK( mk_write_id( c, id ) );
  239.       CHECK( mk_write_size( c, len ) );
  240.       CHECK( mk_append_context_data( c, str, len ) );
  241.   

output/matroska_ebml.c:239: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 239, column 5
  237.   
  238.       CHECK( mk_write_id( c, id ) );
  239. >     CHECK( mk_write_size( c, len ) );
  240.       CHECK( mk_append_context_data( c, str, len ) );
  241.       return 0;
  242.   

output/matroska_ebml.c:240: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 240, column 5
  238.       CHECK( mk_write_id( c, id ) );
  239.       CHECK( mk_write_size( c, len ) );
  240. >     CHECK( mk_append_context_data( c, str, len ) );
  241.       return 0;
  242.   }
  243.   

output/matroska_ebml.c:246: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 246, column 5
  244.   static int mk_write_bin( mk_context *c, unsigned id, const void *data, unsigned size )
  245.   {
  246. >     CHECK( mk_write_id( c, id ) );
  247.       CHECK( mk_write_size( c, size ) );
  248.       CHECK( mk_append_context_data( c, data, size ) );
  249.   

output/matroska_ebml.c:247: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 247, column 5
  245.   {
  246.       CHECK( mk_write_id( c, id ) );
  247. >     CHECK( mk_write_size( c, size ) );
  248.       CHECK( mk_append_context_data( c, data, size ) );
  249.       return 0;
  250.   

output/matroska_ebml.c:248: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 248, column 5
  246.       CHECK( mk_write_id( c, id ) );
  247.       CHECK( mk_write_size( c, size ) );
  248. >     CHECK( mk_append_context_data( c, data, size ) );
  249.       return 0;
  250.   }
  251.   

output/matroska_ebml.c:257: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 257, column 5
  255.       unsigned i = 0;
  256.   
  257. >     CHECK( mk_write_id( c, id ) );
  258.       while( i < 7 && !c_ui[i] )
  259.           ++i;
  260.   

output/matroska_ebml.c:275: warning: UNINITIALIZED_VALUE
  value u.u was not initialized after declaration and is used at line 275, column 14
  273.   
  274.       u.f = f;
  275. >     c_f[0] = u.u >> 24;
  276.       c_f[1] = u.u >> 16;
  277.       c_f[2] = u.u >> 8;
  278.   

output/matroska_ebml.c:285: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 285, column 5
  283.   static int mk_write_float( mk_context *c, unsigned id, float f )
  284.   {
  285. >     CHECK( mk_write_id( c, id ) );
  286.       CHECK( mk_write_size( c, 4 ) );
  287.       CHECK( mk_write_float_raw( c, f ) );
  288.   

output/matroska_ebml.c:286: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 286, column 5
  284.   {
  285.       CHECK( mk_write_id( c, id ) );
  286. >     CHECK( mk_write_size( c, 4 ) );
  287.       CHECK( mk_write_float_raw( c, f ) );
  288.       return 0;
  289.   

output/matroska_ebml.c:287: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 287, column 5
  285.       CHECK( mk_write_id( c, id ) );
  286.       CHECK( mk_write_size( c, 4 ) );
  287. >     CHECK( mk_write_float_raw( c, f ) );
  288.       return 0;
  289.   }
  290.   

output/matroska_ebml.c:293: warning: PRECONDITION_NOT_MET
  in call to calloc() at line 293, column 20
  291.   mk_writer *mk_create_writer( const char *filename )
  292.   {
  293. >     mk_writer *w = calloc( 1, sizeof(mk_writer) );
  294.       if( !w )
  295.           return NULL;
  296.   

output/matroska_ebml.c:338: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 338, column 5
  336.       if( !(c = mk_create_context( w, w->root, 0x1a45dfa3 )) ) // EBML
  337.           return -1;
  338. >     CHECK( mk_write_uint( c, 0x4286, 1 ) ); // EBMLVersion
  339.       CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.   

output/matroska_ebml.c:339: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 339, column 5
  337.           return -1;
  338.       CHECK( mk_write_uint( c, 0x4286, 1 ) ); // EBMLVersion
  339. >     CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.       CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342.   

output/matroska_ebml.c:340: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 340, column 5
  338.       CHECK( mk_write_uint( c, 0x4286, 1 ) ); // EBMLVersion
  339.       CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340. >     CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.       CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342.       CHECK( mk_write_string( c, 0x4282, "matroska") ); // DocType
  343.   

output/matroska_ebml.c:341: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 341, column 5
  339.       CHECK( mk_write_uint( c, 0x42f7, 1 ) ); // EBMLReadVersion
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341. >     CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342.       CHECK( mk_write_string( c, 0x4282, "matroska") ); // DocType
  343.       CHECK( mk_write_uint( c, 0x4287, stereo_mode >= 0 ? 3 : 2 ) ); // DocTypeVersion
  344.   

output/matroska_ebml.c:342: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 342, column 5
  340.       CHECK( mk_write_uint( c, 0x42f2, 4 ) ); // EBMLMaxIDLength
  341.       CHECK( mk_write_uint( c, 0x42f3, 8 ) ); // EBMLMaxSizeLength
  342. >     CHECK( mk_write_string( c, 0x4282, "matroska") ); // DocType
  343.       CHECK( mk_write_uint( c, 0x4287, stereo_mode >= 0 ? 3 : 2 ) ); // DocTypeVersion
  344.       CHECK( mk_write_uint( c, 0x4285, 2 ) ); // DocTypeReadVersion
  345.   

output/matroska_ebml.c:401: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 401, column 5
  399.       if( w->cluster == NULL )
  400.           return 0;
  401. >     CHECK( mk_close_context( w->cluster, 0 ) );
  402.       w->cluster = NULL;
  403.       CHECK( mk_flush_context_data( w->root ) );
  404.   

output/matroska_ebml.c:403: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 403, column 5
  401.       CHECK( mk_close_context( w->cluster, 0 ) );
  402.       w->cluster = NULL;
  403. >     CHECK( mk_flush_context_data( w->root ) );
  404.       return 0;
  405.   }
  406.   

output/matroska_ebml.c:418: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 418, column 9
  416.       delta = w->frame_tc/w->timescale - w->cluster_tc_scaled;
  417.       if( delta > 32767ll || delta < -32768ll )
  418. >         CHECK( mk_close_cluster( w ) );
  419.   
  420.       if( !w->cluster )
  421.   

x264.c:1421: warning: UNINITIALIZED_VALUE
  value defaults.i_log_level was not initialized after declaration and is used at line 1421, column 21
  1419.   
  1420.       x264_param_default( &defaults );
  1421. >     cli_log_level = defaults.i_log_level;
  1422.   
  1423.       memset( &input_opt, 0, sizeof(cli_input_opt_t) );
  1424.   

x264.c:1857: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 1857, column 5
  1855.       i_frame_size = x264_encoder_encode( h, &nal, &i_nal, pic, &pic_out );
  1856.   
  1857. >     FAIL_IF_ERROR( i_frame_size < 0, "x264_encoder_encode failed\n" );
  1858.   
  1859.       if( i_frame_size )
  1860.   

x264.c:1861: warning: UNINITIALIZED_VALUE
  value nal was not initialized after declaration and is used at line 1861, column 54
  1859.       if( i_frame_size )
  1860.       {
  1861. >         i_frame_size = cli_output.write_frame( hout, nal[0].p_payload, i_frame_size, &pic_out );
  1862.           *last_dts = pic_out.i_dts;
  1863.       }
  1864.   

x264.c:1861: error: DANGLING_POINTER_DEREFERENCE
  uninitialized pointer nal could be dangling and is dereferenced or freed at line 1861, column 54
  1859.       if( i_frame_size )
  1860.       {
  1861. >         i_frame_size = cli_output.write_frame( hout, nal[0].p_payload, i_frame_size, &pic_out );
  1862.           *last_dts = pic_out.i_dts;
  1863.       }
  1864.   

x264.c:1949: warning: CONDITION_ALWAYS_FALSE
  Boolean condition  (0!=0) is always false at line 1949, column 9
  1947.           pulldown = &pulldown_values[opt->i_pulldown];
  1948.           param->i_timebase_num = param->i_fps_den;
  1949. >         FAIL_IF_ERROR2( fmod( param->i_fps_num * pulldown->fps_factor, 1 ),
  1950.                           "unsupported framerate for chosen pulldown\n" );
  1951.           param->i_timebase_den = param->i_fps_num * pulldown->fps_factor;
  1952.   

x264cli.h:50: warning: CONDITION_ALWAYS_TRUE
  Boolean condition  (1!=0) is always true at line 50, column 12
  48.   static inline uint64_t gcd( uint64_t a, uint64_t b )
  49.   {
  50. >     while( 1 )
  51.       {
  52.           int64_t c = a % b;
  53.   

Summary of the reports

                      CONDITION_ALWAYS_FALSE: 103
                      ARRAY_OUT_OF_BOUNDS_L1: 84
                       CONDITION_ALWAYS_TRUE: 43
                        PRECONDITION_NOT_MET: 26
                      ARRAY_OUT_OF_BOUNDS_L2: 16
                                 MEMORY_LEAK: 10
                         UNINITIALIZED_VALUE: 9
  UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION: 3
                              DIVIDE_BY_ZERO: 2
                DANGLING_POINTER_DEREFERENCE: 2
